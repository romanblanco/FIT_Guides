\documentclass[a4paper,10pt]{article}
\usepackage[IL2]{fontenc}
\usepackage[latin2]{inputenc}
\usepackage[top=2cm, left=1.5cm, text={18cm, 26cm}]{geometry}
\usepackage{graphics}
\usepackage[czech]{babel}
\usepackage{alltt}


\newcommand{\pojem}[2]{\item \textbf{#1:}\quad #2}
\newcommand{\tedy}{$\Rightarrow$ }

\begin{document}
	{\Huge IPP Guide}\\[2cm]

	\begin{quote}
	Jedná se neoficiálního prùvodce pøedmìtem Principy programovacích jazykù a OOP. První èást je výtahem ze v¹ech tøí opor a následující èást obsahuje otázky z let 2011-2014 s vypracováním. \\

	\textbf{Toto není jediný materiál pro studium ke zkou¹ce, doporuèujeme jej kombinovat s pøedná¹kami a ji¾ zmiòovanými oporami.} \\

	Dokument mù¾e obsahovat pravopisné chyby, za které se pøedem omlouváme a budeme rádi, za pøípadné upozornìní. 
	\end{quote}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Doplneni teorie %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\vfill
	\tableofcontents
	\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Teorie}
		Následující 3 podsekce obsahují pomìrnì struèný výcuc ze v¹ech tøí opor. Pokusil jsem se vypsat v¹e dùle¾ité, definice, to co bylo na nìkterém z termínù apod.
	
		\subsection{Opora 1\,--\,jazyky}
			\paragraph{Imperativní jazyk} je takový, kde programátor musí øe¹it tyto otázky øízení bìhu programu:
			\begin{itemize}
				\item co za operace má být provedeno
				\item v jakém poøadí to má být provedeno
			\end{itemize}

			\paragraph{Deklarativní jazyk} je takový, kde programátor musí øe¹it tuto otázku øízení bìhu programu:
			\begin{itemize}
				\item co za operace má být provedeno
			\end{itemize}

			\paragraph{Procedurální jazyk} sestavuje program jako posloupnost pøíkazù, z nich¾ nìkteré a u nìkterých jazykù lze také vnoøovat.

			\paragraph{Syntaxe jazyka} definuje strukturu programu, tj. to, jakým zpùsobem je dovoleno jednotlivé konstrukce øadit za sebe.
			\paragraph{Sémantika} je popis/definice významu jednotlivých syntaktických konstrukcí, zpùsobu jejich vyhodnocení, zpracování, atd.
			\begin{itemize}
				\pojem{Axiomatická sémantika}{pro ka¾dou syntaktickou konstrukci definuje mno¾inu axiomù, které musí být splnìny, aby byla kostrukce platná}
				\pojem{Operaèní sémantika}{definuje sémantiku chování programu jako posloupnost pøechodù mezi danými stavy}
				\pojem{Denotaèní sémantika}{program je definován jako matematická funkce, která zobrazuje vstupy na výstupy}
			\end{itemize}

			\begin{itemize}
				\item Statická sémantika -- popisuje vlastnosti, které mohou být studovány a ovìøovány v dobì analýzy/pøekladu programu, napø. existence promìnných, nemo¾nost dìlit nulou, ...
				\item Dynamická sémantika -- popisuje vlastnosti, jejich¾ splnìní lze ovìrit a¾ v dobì bìhu programu, napø. velikost indexu pole daného výrazem, apod.
			\end{itemize}

			\paragraph{Deklarace} úplnì vymezuje atributy dané entity, mù¾e být explicitní i implicitní. Atributy jsou napø. jméno, parametry
			\paragraph{Definice} úplnì vymezuje atributy dané entity a dále u promìnných zpùsob alokace (pøesnìji pøidìlování) pamìti a u funkcí/procedur navíc tìlo funkce.

			\paragraph{Rozsah platnosti promìnné} urèuje tu èást programu, kdy je mo¾né s promìnnou pracovat.
			\paragraph{Doba ¾ivota promìnné} \emph{je èasový interval}\footnote{Nezamìòovat za délku, apod. Pøímo vy¾adují "èasový interval"}, po který je pro danou promìnnou alokována pamì».

			\subsubsection{Nestrukturované jazyky}
				\paragraph{Formální báze} je takový formální prostøedek (kalkul, algebra, apod.), který umo¾òuje exaktnì popsat v¹echny konstrukce daného jazyka.

				\paragraph{Otevøený podprogram} je ulo¾en v rámci hlavního (èasto jediného) zdrojového textu. Nemá definované pevné rozhraní, tzn. vstupní a výstupní bod, parametry, výsledek apod. Vstup se dìje skokem na pøíkaz, jím¾ má výpoèet podprogramu zaèít, ukonèení podprogramu je dáno vyvoláním pøíslu¹ného pøíkazu (nikolv dobìhnutím výpoètu do/za urèité místo)
				\begin{itemize}
					\item Parametry i výsledky jsou pøedávány jen jako globální promìnné -- neexistují lokální promìnné, tudí¾ je jednoduché udìlat chybu, kdy dojde k pøepsání jiných dat
					\item Implicitní podpora rekurze chybí -- v urèitých pøípadech mù¾e øe¹it programátor ve vlastní re¾ii (kdy¾ má k dispozici zásobník volání)
					\item Slo¾itá struktura programu -- vìt¹í a slo¾itìj¹í programy mohou být vytvoøeny tak, ¾e jejich pochopení/úprava mù¾e být velmi slo¾itá
				\end{itemize}
				
				\paragraph{Analyzátor}{je program, který analyzuje vstupní text v nìjakém programovacím jazyce a provádí jeho dùkladnou kontrolu pouze na základì jeho textu. Výstupem je potom potenciální seznam chyb, varování èi doporuèení k danému programu.\footnote{My¹len program, zkoumající text a chování, nemusí být souèástí pøekladaèe}}
				\paragraph{Interpret}{je takový program, který jakmile rozpozná nìjaký pøíkaz ve vstupním programu, tak jej ihned provede. Pøevádí tak vstupní program na posloupnost okam¾itì provádìných akcí}
				\begin{itemize}
					\pojem{Lexikální analýza}{probíhá co nejdøíve, ale jen v omezeném rozsahu}
					\pojem{Syntaktická analýza}{probíhá po øádcích}
					\pojem{Sémantická analýza}{je mo¾né provádìt v posloupnosti a nebo ji odlo¾it a¾ na samotné vyhodnocení}
				\end{itemize}
				\paragraph{Pøekladaè}{je program, který vstupní text programu pøevádí na posloupnost pøíkazù jiného jazyka èi stroje. Cílem takového pøekladu mù¾e být napø. binární soubor, který je pøímo spustitelný na dané architektuøe (HW + OS)}
				\begin{itemize}
					\pojem{Lexikální analýza}{pro nestrukturované jazyky, nic zvlá¹tního}
					\pojem{Syntaktická analýza}{typycké bezkontextové vlastnosti a je mo¾né vyu¾ít pøíslu¹né formální aparáty}
					\pojem{Sémantická analýza}{u typických pøedstavitelù pomìrnì v pozadí, lze bezpeènì kontrolovat pouze existenci cíle skoku}
					\pojem{Generování kódu}{ka¾dý pøíkaz se pøekládá oddìlenì nebo je mo¾né program analyzovat jako celek, tak¾e je mo¾né aplikovat celou øadu optimalizací}
				\end{itemize}
				
			\subsubsection{Strukturované jazyky}
				\paragraph{Formální báze} strukturované jazyky ji primárnì nemají, proto¾e byl jazyk navr¾en bez formalismù
				\paragraph{Syntaxe} je podávána formální, èi semiformální cestou
				\paragraph{Sémantika} popis èasto veden neformální cestou, popis èasto velmi propracovaný
				\paragraph{Floyd-Hoare logika} specifikuje pravidla pro práci se základními konstrukcemi jazyka. Kromì toho urèuje i pravidla pro práci s èísly a jejich ekvivalenty.
				\begin{quote}
					\emph{Nech» C oznaèuje pøíkaz, P oznaèuje podmínku platnosti pøed provedením pøíkazu a Q podmínku platící po provedení pøíkazu, potom zápis $\{P\}C\{Q\}$ vyjadøuje parciální správnost vztahu podmínek a pøíkazu a zápis $[P]C[Q]$ úplnou správnost}
				\end{quote}
	
				\paragraph{Ukazatele} umo¾òují vznik rekurzivních datových struktur tím, ¾e umo¾òují odkazovat urèitému typu dat na sebe sama.
				\paragraph{Pervasivní funkce} jsou pøítomny pro manipulaci s daty, které jsou v jazyce pøímo definovány, nicménì u¾ivatel mù¾e vytvoøit funkci stejného jména.
				\paragraph{Definice\,/\,deklarace} umístìní deklarací mù¾e být na rùzných místech
				\paragraph{Návrh programu} dùle¾ité vlastnosti:
				\begin{itemize}
					\pojem{Vznik uzavøených podprogramù}{zjednodu¹uje:}
					\begin{itemize}
						\pojem{Rekurzi}{vùbec první pøímoèará mo¾nost pou¾ití rekurze}
						\pojem{Ukrytí implementace}{nelze náhodnì do kódu pøistoupit, jediný vstupní bod, jasnì definované rozhraní vstupu/výstupu\footnote{Parametry, návratová hodnota,...}}
						\pojem{Odluka od hlavního toku programu}{jednodu¹¹í a bezpeènìj¹í modifikace, explicitní vyvolání, atd.}
					\end{itemize}
					\item Lokální promìnné v zanoøených blocích \tedy promìnné stejného jména, rùzného významu, rùzný rozsah platnosti
				\end{itemize}
				\paragraph{Týmová spolupráce} nemají tolik mo¾ností jako modulární, ale poskytují:
				\begin{itemize}
					\item uzavøené podprogramy mohou být vytváøeny nezávisle: datové manipulátory, èistì výpoèetní funkce, atd.
					\item program je mo¾né rozdìlit na logicky nezávislé celky: tyto lze dále vyu¾ít v jiných projektech
				\end{itemize}
				\paragraph{Pøísné typování} rozli¹ujeme, zda-li typové konverze probíhají implicitnì dle daných pravidel, nebo je v¾dy nutná explicitní konverze
				\paragraph{Harvardská architektura} logicky oddìluje prostor pro data a pro ulo¾ení kódu v pamìti \footnote{Von Neumannova architektura oproti Harvardské pou¾ívá spoleènou pamì» pro data i program, pou¾ívá teda sekvenèní zpracování}
				\paragraph{Datové struktury} jejich¾ tvorba je plnì pod kontrolou u¾ivatele, jsou revolucí strukturovaných programovacích jazykù na úrovni tvorby a definice dat.
				\begin{itemize}
					\pojem{Variantní datová struktura}{sjednocení jednotlivých slo¾ek struktury, ka¾dá slo¾ka má jméno a typ \footnote{Jednotlivé slo¾ky jsou sjednoceny do mno¾iny}
					\pojem{N-tice}{ukládají jednotlivé slo¾ky v pamìti za sebou, zpravidla bez mezer}
					\pojem{Bitová pole}{zarovnávají svou velikost na velikost nejbli¾¹íme vy¹¹ího bytu èi slova}
					\pojem{Pole}{homogenní datová struktura, kdy ka¾dá slo¾ka je pevnì indexována urèitou hodnotou a v¹echny slo¾ky jsou stejného typu}
					\item \textbf{Kompatibilita typù} u polí datových struktur se posuzuje dvìma zpùsoby:
					\begin{itemize}
						\item Shoda typu na jméno
						\item Shoda typu dle shody vnitøní struktury
					\end{itemize}
					\pojem{Pøedávání struktury parametrem}{existují tyto pøístupy}
					\begin{itemize}
						\pojem{Nelze}{jazyk nepodporuje pøedávání datových struktur jako parametry pøedávané hodnotou}
						\pojem{Pøedání odkazem}{manipuluje prostøednictvím odkazù}
						\pojem{Pøedání hodnotou}{implementace standardním zpùsobem, nicménì mù¾e být limitována velikost takto pøedávané struktury}
					\end{itemize}
				\end{itemize}

				\paragraph{Tok øízení programu}
				\begin{itemize}
					\pojem{Statické zanoøení}{vnoøení na úrovni textu programu}
					\pojem{Dynamická úroveò zanoøení}{jednotlivé funkce se navzájem volají, pøípadnì rekurzivnì samy sebe}
					\item Øe¹ení pøístupu k promìnným:
					\begin{itemize}
						\pojem{Display}{paralelní zásobník k programovému s ukazateli na aktuální pozici promìnných z dané statické úrovnì}
						\pojem{Pøístupové ukazatele}{ka¾dá funkce dostane jako skrytý parametr ukazatele na aktuální promìnné z~vy¹¹ích úrovní}
					\end{itemize}
				\end{itemize}
				\paragraph{Pøekladaè} lexikální, syntaktická a sémantická analýza lze provést najednou v rámci jednoho prùchodu zdrojovým textem. Syntaxi jazykù lze popsat bezkontextovými gramatikami.
				\begin{itemize}
					\pojem{Lexikální analýza}{je nutné rozeznávat více kategorií lexikálních symbolù, nejzatí¾enej¹í èást pøekladaèe}
					\pojem{Syntaktická analýza}{pou¾ívají prediktivní analyzátor jazykù tøídy LL(1), pracuje zhora dolù}
					\pojem{Sémantická analýza}{potøebuje víceúrovòové tabulky symbolù, èasto provádìna typová kontrola, ovìøení, zda existuje entita protøebného typu a jména, detekce cíle skokù}
				\end{itemize}
				\paragraph{Interpret} rozsah definic v rámci bloku má dlouhý dosah \tedy je nutné si pamatovat, kde se nacházíme. Skoky komplikují situaci pokud \tedy skok mimo blok, skok dopøedný
				
				Analýza provádìná v¾dy na úrovni bloku, typický pøeklad do vnitøní reprezentace.

				Výhody a nevýhody jsou:
				\begin{itemize}
					\item Detekce chyb je mo¾ná mnohem døíve ne¾ u èisté interpretace
					\item Spotøeba pamìti roste
					\item Vykonání programu je rychlej¹í
					\item Pou¾ití v re¾imu inkrementálních zmìn programu a jejich okam¾itého promítnutí do vyhodnocení \tedy zastavení, modifikace a spu¹tìní programu od místa zastavení je obtí¾né
				\end{itemize}

			\subsubsection{Modulární jazyky}
				\paragraph{Formální báze} primárnì ji nemají, a¾ na výjimky
				\paragraph{Syntaxe} podávána formální, èi semiformální cestou jako u strukturovaných jazykù.
				Typicky u¾ívané popisy:
				\begin{itemize}
					\item (E)BNF -- roz¹íøená Backus-Naurova forma
					\item Syntaktické grafy
					\item Formální gramatiky -- zejména bezkontextové
				\end{itemize}
				\paragraph{Sémantika} neformální, díky modulùm je umo¾nìn vznik i knihoven funkcí. Vznikají standardy knihoven k jednotlivým jazykùm.
				\paragraph{Softwarové in¾enýrství} z tohoto pohledu se modulární jazyky dostávají na vrchol a koncept modularizace je úspì¹nì vyu¾íván dodnes. Týmová spolupráce a dekompozice problémù, vy¾aduje pochopení a aplikaci øady postupù u¾ v dobì návrhu.
				Modularizace pøiná¹í i nový typ chyb:
				\begin{itemize}
					\item Nemo¾nost spojit moduly do výsledného celku díky ¹patné specifikaci modulù, èi nevhodné dekompozici
					\item Program lze sestavit, ale díky ¹patné logice øízení toku programu celek nepracuje správnì, èi ''zamrzává''
					\item Nevhodné u¾ití návrhových metodologií pro modularizaci, èi vazby mezi moduly jak na úrovni dat, tak na úrovni toku øízení -- grafy toku øízení, koneèné automaty, událostí apod.
				\end{itemize}
				\paragraph{Role knihoven} poskytují sadu funkcí pro manipulaci s urèitým abstraktním typem, pøípadnì poskytují zázemí pro danou výpoèetní tématiku.
				\paragraph{Skrývání dat} modul se stará, jak o data definovaná a nabízená modulem, tak o data skrytá v modulu. Mohou vznikat chyby v pøípadì, ¾e neznáme zdrojové kódy modulù.
				\paragraph{Rozhraní modulu} o vyvá¾ených datech, datových typech a funkcích z modulu rozhoduje rozhraní (interface). Obsahuje i deklarace pro jednotlivé konstrukce. 
				\paragraph{Závislosti mezi moduly} primárnì se pou¾ívá stromová hierarchie, nìkdy se jedná o acyklický orientovaný graf (DAG). U nestromových struktur vzniká problém s násobným u¾itím modulu, který ale podobné zacházení nepodporuje.
				\paragraph{Deklarace typù} vìt¹ina jazykù nepodporuje skrývání definic typù na vhodné úrovni, èasto vùbec.
				\paragraph{Skrývání implementace} výhodou je umo¾nìní skrývání implementace v implementaèní èásti modulu. Nevýhodou mù¾e být nemo¾nost sdílení jednoho modulu více dal¹ími, pokud na to není pøipraven a zdrojové texty jsou nedostupné.

				\paragraph{Tok øízení programu} pøibývá mo¾nost pøedávat øízení z jednoho modulu do druhého. V dobì pøekladu je obecnì znám pouze jeden modul, pøípadnì jejich omezené mno¾ství, nastávají problémy:
				\begin{itemize}
					\item jak pøedat parametry
					\item jak vrátit/pøijmout výsledek funkce
					\item jak vyu¾ít registry pro optimalizaci
				\end{itemize}	
				Dùsledky jsou potom:
				\begin{itemize}
					\pojem{Pøiøazování registrù}{dìje se pouze v rámci funkce -- pokud nejsou vyu¾ity specializované registry v nìjakém modulu, mo¾nost je pøiøadit globálnì na závìr}
					\pojem{Standardizace pøedávání parametrù}{volající i volaný dodr¾ují urèité konvence}
					\pojem{Standardizace pøedávání výsledku}{volající i volaný dodr¾ují urèité konvence}
				\end{itemize}
				Zpùsoby pøedávání parametrù:
				\begin{itemize}
					\pojem{Hodnotou, výsledkem, hodnotou a výsledkem}{vytváøí se kopie, které hodnota se pøípadnì kopíruje zpìt}
					\pojem{Odkazem}{pøedává se ukazatel na danou promìnnou}
					\pojem{Jménem}{pøedává se dvojice pøístupových metod k dané entitì: pro zápis a ètení hodnoty}
				\end{itemize}

				\paragraph{Pøekladaè} kopírují se vlastnosti, které jsou dány charakterem jazyka z hlediska typù a øídících struktur. Nìkteré operace nejsou mo¾né:
				\begin{itemize}
					\item Nìkteré druhy globálních optimalizací nelze provádìt díky neznalosti kompletního programu
					\item Volání a návrat z volání funkcí musí probíhat pøes standardní rámec
					\item Objevuje se spojovací program, který pøebírá nìkteré role pøekladaèe

					\pojem{Lexikální analýza}{vlastní textový preprocesor, zprvu implementován jako separátní program spou¹tìný je¹tì pøed vlastním pøekladaèem, souèasnì souèástí lexikálního analyzátoru}
					\pojem{Syntaktická analýza}{modulární jazyky jsou zalo¾eny na bezkontextových gramatikách \tedy zpracování standardním zpùsobem}
					\pojem{Sémantická analýza}{generování cílového kódu probíhá do jeho relativní formy s tím, ¾e je nutný je¹tì prùchod spojovacího programu}
				\end{itemize}
				\paragraph{Spojovací program (linker)}spojuje v¹echny moduly a èásti knihoven do jediného bloku, proveditelného souboru -- sestavuje cílový kód.
				Vznikají chyby:
				\begin{itemize}
					\pojem{Chybìjící symbol}{nìkterý z modulù po¾aduje symbol, který ale ¾ádný jiný modul nedefinuje, nebo tuto definici nevyvá¾í}
					\pojem{Vícenásobná definice}{nìkterý ze symbolù je definován a exportován více moduly}
					\pojem{Rozdílné typy symbolù}{ne v¹echny linkery tuto chybu detekují, konflikt mezi typem souboru, který je vyvá¾en jedním a dová¾en jiným modulem}
				\end{itemize}
				Popis linkeru:
				\begin{itemize}
					\pojem{Vstup linkeru}{je relativní kód, který je výstupem pøekladu, má vazby na promìnné, funkce uskuteènìny pøes tabulku. Èasto obsa¾ena i tabuka pro lokální symboly v modulu.}
					\pojem{Úloha linkeru}{spojování a vzájemné provazování symbolù, které nìco po¾adují, se symboly, které jiný modul vyvá¾í. Bìhem provazování se provádí kontrola na existenci, násobné nebo chybìjící definice. Výstupem je relokatibilní kód nebo absolutní kód.}
					\pojem{Absolutní kód}{linker musí kromì vzájemného propojení symbolù urèit i adresu v¹ech entit programu a zmodifikovat kód, který na nì odkazuje.}
				\end{itemize}

				\paragraph{Interpret} nejsou typické, pouze pro ¹kolní nebo výzkumné projekty.
				\begin{itemize}
					\item Interprety virtuálního kódu -- vylep¹uje vlastnosti interpretù, proto¾e eliminuje nutnost opakované analýzy zdrojového textu, pøitom umo¾òuje rychlou modifikaci kódu jednotlivých funkcí, mo¾nosti ladìní programu jsou teoreticky také na vysoké urovni
				\end{itemize}
				
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			
		\subsection{Opora 2\,--\,objektovì orientované programování}
			\subsubsection{Objektovì orientované programování}
			Jedná se o zpùsob abstrakce, kdy algoritmus implementujeme pomocí mno¾iny zapouzøených vzájemnì komunikujících entit, z nich¾ ka¾dá má plnou výpoèetní mocnost celého poèítaèe.
			\paragraph{Objektovì orientovaný systém (program, aplikace)} se skládá z jednoho èi více objektù, které spolu komunikují a interagují pøi spolupráci na øe¹ení daného problému.
			Hlavní výhody OOP:
			\begin{itemize}
				\item Analogie mezi softwarovým modelem a reálným modelem
				\item Flexibilita takovýchto softwarových modelù
				\item Jejich znovupou¾itelnost
			\end{itemize}
			Základní pojmy:
			\begin{itemize}
				\pojem{Objekt}{jednoznaènì identifikovatelný reálný objekt nebo abstrakci, která zahrnuje data a jejich chování. V tøídním jazyce se jedná o instanci tøídy obsahující data a operace. Pøípadnì: objekt je entita zapouzdøující stavové informace a poskytující sadu operací nad tímto objektem nebo jeho èástmi}
				\pojem{Zpráva}{Zpráva je komunikaèní jednotka mezi dvìma libovolnými objekty. Ka¾dá zpráva má svého odesílatele a pøíjemce. Sémantika zprávy}
				\begin{itemize}
					\item[1.] Pøíjemce obdr¾í zprávu od odesílatele
					\item[2.] Vyhledá patøiènou implementaci reakce na tuto zprávu
					\item[3.] Vìt¹inou se jedná o zapouzdøenou funkci (metoda)
					\item Metody implementují ve¹keré chování objektù (reakce na obdr¾ené zprávy)
					\item Zprávy a metody mívají shodné jméno i seznam parametrù
					\pojem{Protokol objektu}{mno¾ina zpráv, kterým objekt rozumí}
				\end{itemize}
			\end{itemize}

			\paragraph{Základní koncepty OOP} OOP sluèuje nové programovací koncepty a vylep¹uje staré, aby tak dosáhlo pøiblí¾ení popisu reálného svìta k lidskému zpùsobu uva¾ování.
			\begin{itemize}
				\pojem{Objekty}{spojují data a funkcionalitu spoleènì do jednotek zvaných objekty, ze kterých se potom skládá výsledný objektovì orientovaný program na rozdíl od strukturovaného slo¾eného z procedur a funkcí}
				\pojem{Abstrakce}{neboli schopnost programu ignorovat/zjednodu¹it/zanedbat nìkteré aspekty informací èi vlastností objektù, se kterými program pracuje.}
				\pojem{Zapouzdøení}{zaji¹»uje ji¾ na úrovni definice sémantiky jazyka, ¾e u¾ivatel nemù¾e mìnit interní stav objektù libovolným zpùsobem, ale musí k tomu vyu¾ívat poskytované rozhraní. Ka¾dý objekt tedy nabízí protokol, který urèuje, jak s ním mohou ostatní objekty interagovat}
				\pojem{Polymorfismus}{mnohotvárnost, vyu¾ívá mechanismus zasílání zpráv. Konkrétné pou¾itá metoda reagující na zaslání zprávy závisí na konkrétním objektu, jemu¾ je tato zpráva zaslána. Ka¾dý objekt mù¾e mít rùznou implementace jedné procedury/funkce}
				\pojem{Dìdiènost}{zpùsob, jak implementovat sdílené chování. Nové objekty tak mohou sdílet a roz¹iøovat chování tìch ji¾ existujících bez nutnosti v¹e znovu reimplementovat.}
			\end{itemize}

			\paragraph{Pøiøazení} pojmenování objektu neboli pøiøazení objektu do promìnné. Místo objektu se mù¾e pracovat s referencí nebo ukazatelem na daný objekt.
			\paragraph{Zasílání zprávy} Zpráva kromì identifikátoru mù¾e obsahovat i parametry. Reakce objektu na zprávu je individuální v závislosti na konceptu zapouzdøení a polymorfismu. Pøi obdr¾ení zprávy pøíjemcem mohou nastat situace:
			\begin{itemize}
				\item Objekt ve své implementaci reagování na zprávu nalezne a zavolá pøíslu¹nou metodu
				\item Objekt hledanou metodu pøímo neobsahuje, ale obsahuje ji jiný objekt v rodièovském vztahu s tímto objektem. Je závislý na konceptu dìdiènosti a tzv. smìrování zpráv.
				\item Objekt neobsahuje implementaci odpovídající metody a ani nebyla nalezena v objektech pøedkù. Nastává chyba, ¾e pøedané zprávì nebylo rozumìno \tedy neexistuje odpovídající metoda. Nìkteré jazyky tento pøípad doká¾ou rozpoznat ji¾ pøi pøekladu.
			\end{itemize}

			\paragraph{Výhody/nevýhody OOP}
			\begin{itemize}
				\item[$+$] Vy¹¹í míra abstrakce 
				\item[$+$] Pøirozenìjí práce se zapouzdøením a moduly \tedy SW objekt analogií/abstrakcí reálného objektu a lze jej pova¾ovat za samostatný modul 
				\item[$+$] Jednodu¹¹í dekompozice problémù \tedy rozdìlení mezi abstrakci a zapouzdøení
				\item[$+$] Udr¾ovatelnost a roz¹iøitelnost \tedy robustnost, zmìny mají lokální charakter ve vztahu k objektùm a tøídám
				\item[$+$] Znovupou¾itelnost \tedy mo¾nost vyu¾ívat cizích obejktù pøi znalosti jejich rozhraní respektive protokolu pro komunikaci s nimi
				\item[$-$] V nìkterých pøípadech neexistuje analogie s reálnými objekty a pak je obtí¾né urèit a definovat intuitivnì ty softwarové
				\item[$-$] Slo¾itìj¹í sémantika ne¾ u modulárních a strukturovaných jazykù \tedy vy¾aduje více èasu k nauèení
				\item[$-$] Nemo¾nost poru¹ovat koncepci zapouzdøení
				\item[$-$] Výsledný kód je pomalej¹í \tedy vyu¾ívání dodateèných kontrol, odli¹ných modelù výpoètu
				\item[$-$] Re¾ie na ulo¾ení objektù v pamìti
			\end{itemize}

			\paragraph{Tøída} je ¹ablona (otisk), podle ní¾ mohou být vytváøeny objekty (instance této tøídy). Tøída se také stará o správu protokolu objektu, smìrování zpráv a obsahuje implementace nìkterých metod.

			\paragraph{Instanciace objektù} je proces vytváøení objektu pomocí pøedpisu daného konkrétní tøídou. Instance tøídy je objekt, který obsahuje naplnìny instanèní promìnné a odkaz na tøídu, ze které vznikl. Bezprostøednì po vytvoøení objektu dostáváme prázdný prázdný objekt, jeho¾ datové polo¾ky musejí být teprve naplnìny (inicializovány) \tedy k tomu slou¾í konstruktor. Pro operaci vytvoøení objektu se pou¾ívá klíèové slovo \texttt{new}, které obsahuje jako parametr jméno tøídy, která pro nìj bude slou¾it jako konstrukèní ¹ablona, a pøípadný seznam parametrù
			\paragraph{Kopírování objektù} je dal¹í zpùsob vytváøení objektù, hovoøíme o klonování objektù:
			\begin{itemize}
				\pojem{Hluboká kopie}{kromì objektu jsou kopírovány i objekty, které referencují instanèní promìnné kopírovaného objektu}
				\pojem{Mìlká kopie}{je vytvoøen nový objekt, ale v¹echny instanèní promìnné obsahují odkazy na toto¾né objekty jako kopírovaná pøedloha}
			\end{itemize}

			\paragraph{Manipulace s objekty v kódu a v pamìti} v pøípadì pøiøazení objektu do promìnné:
			\begin{itemize}
				\item[a)] Nìkteré jazyky rozli¹ují, zda je objekt alokovaný na zásobníku a nebo na haldì \tedy rozli¹ují mezi datovým záznamem objektu a pouhou referencí na objekt
				\item[b)] Naopak nìkteré jazyky tento rozdíl skrývají a pracují s objekty pouze pøes reference \tedy lze tak u¹etøit pamì» nejen pøi provádìní pøíkazù pøiøazení, ale také pøi pøedávání parametrù
			\end{itemize}

			\paragraph{Ru¹ení objektù v pamìti}
			\begin{itemize}
				\pojem{Automaticky}{je mo¾né pouze v pøípadì bìhu objektového prostøedí ve virtuálním stroji, provádí jej Garbage Collector, který vyhledává objekty, na které ji¾ neexistuje ¾ádný odkaz a ty zru¹í. Je mo¾né tìsnì pøed zru¹ením zavolat metodu pro úklid a uvolnìní alokovaných zdrojù mimo objekt $=$ finalizace}
				\pojem{Manuálnì}{v pøípadì, ¾e nemáme Garbage Collector, musíme objekty ru¹it manuálnì. Pro likvidaci objektù slou¾í destruktor, metoda která je volaná programátorem.}
			\end{itemize}

			\paragraph{Úèely dìdiènosti}
			\begin{itemize}
				\item[1.] Znovupou¾ití definované tøídy pro specifiètìj¹í verzi tøídy
				\item[2.] Zaji¹tìní zpìtné kompatibility z pohledu rozhraní instancí zdìdìných tøíd
			\end{itemize}

			\paragraph{Klasifikace dìdiènosti} A ''Kolik rodièù mù¾e mít potomek'' a B ''Co se dìdí''
			\begin{itemize}
				\item[A$_\textrm{1}$)] \textbf{Jednoduchá dìdiènost} øíká, ¾e ka¾dý potomek má nejvý¹e jednoho pøímého pøedka (rodièe)
				\item[A$_\textrm{2}$)] \textbf{Vícenásobná dìdiènost} je pøípad, kdy mù¾e tøída dìdit od více pøímých pøedkù (více jak jednoho). Vznikají konflikty v jménech èlenù nadtøíd, pøípadnì vy¾adování uvádìní klasifikace pøedka, ze kterého konfliktní metody invokovat. Je vhodné vytvoøení optimálního a nejpou¾itelnìj¹ího algoritmu pro vyhledávání metod, kdy je nutno procházet orientovaný graf nejen jednoduchý strom.
				\item[B$_\textrm{1}$)] \textbf{Dìdiènost implementace} do dìdiènosti jsou zahrnuty atributy i celé metody vèetnì jejich implementace. Zde vzniká problém se dvìmi stejnì pojmenovanými metodami ale s rùznou implementací nebo se stejnì pojmenovanými instanèními promìnnými.
				\item[B$_\textrm{2}$)] \textbf{Dìdiènost rozhraní} pro vyu¾ívání vícenásobné dìdiènosti, ale odstranìní problémù s konfliktními jmény, vzniká pøístup dìdìní na úrovni roz¹iøování protokolu objektu. 
			\end{itemize}

			\paragraph{Statické metody a promìnné} jsou zapsány pøímo v definici tøídy a jsou oznaèeny pøedepsaným klíèovým slovem \verb|static|. Dá se k nim pøistupovat mimo instance tøídy\footnote{Napøíklad pøi poèítání absolutní hodnoty ze tøídy \texttt{Math} není nutné vytváøet instanci tøídy \texttt{Math} a a¾ pak volat funkci \texttt{abs()}, staèí tedy zavolat \texttt{Math.abs()}, ale \texttt{abs()} musí být statická metoda}

			\paragraph{Typy, podtypy a nadtypy} jedná se o vztahy mezi objekty, tøídami a potomky
			\begin{itemize}
				\pojem{Typ}{v pøípadì tøídy, podobnì jako abstraktní datový typ má i tøída operace a vnitøní ulo¾ení dat}
				\pojem{Nadtyp}{pøedek, nadtyp (superclass)}
				\pojem{Podtyp}{potomek, podtyp (subclass)}
			\end{itemize}
			
			\paragraph{Vy¾adovaná dìdiènost} v pøípadì, ¾e je instance tøídy nebo z ní zdìdìné tøídy vy¾adována na místì parametru metody. Dìdièný vztah zaji¹»uje existenci potøebného protokolu.

			\paragraph{Skuteèný podtyp} Pokud potøebujeme více volnosti s dosazováním za parametry metod, tak musíme vyu¾ít jiný zpùsob zaji¹tìní existence metod. Kontrola existence po¾adovaných metod v konkrétním dosazovaném typu se nazývá kontrola skuteèného podtypu.

			\paragraph{Pøístupy k typùm v tøídních jazycích:}
			\begin{itemize}
				\pojem{Èistì objektový}{v¹e je objekt a existuje tøída nebo pøípadnì objekt, od kterého jsou v¹echny ostatní odvozeny}
				\pojem{Hybridnì objektový}{k dispozici sada základních neboli primitivních typù, které lze pøípadnì skládat do homogenních nebo heterogenních struktur. Tøída je heterogenní struktura, která mù¾e obsahovat atributy i metody:}
				\begin{itemize}
					\item[a)] Existuje koøenová tøída, která je pøedkem ka¾dé existující nebo nové tøídy
					\item[b)] Jazyky, které nemají v hierarchii dìdiènosti ¾ádnou koøenovou tøídu
				\end{itemize}
			\end{itemize}

			\paragraph{Staticky a dynamicky typované jazyky}
			\begin{itemize}
				\pojem{Staticky typovaný jazyk}{urèuje mno¾inu operací, které objekt podporuje, ji¾ v dobì pøekladu programu. V pøípadì po¾adované nepodporované operace skonèí pøeklad neúspì¹nì.}
				\pojem{Dynamicky typovaný jazyk}{kontrolu provádí a¾ v dobì bìhu programu. V pøípadì, ¾e objekt operaci nepodporuje, je proveden pokus o konverzi objektu na jiný typ a pøípadnì vygenerována chyba.}
			\end{itemize}

			\paragraph{Redefinice metod (overriding)} je mo¾nost jazka definovat metodu podtøídy s novou, specifiètìj¹í implementacím, ne¾ je obsa¾ena v její nadtøídì. Obì metody pøitom pøitom mají stejnou sigaturu jak v nadtøídì.
			Redefinice metod je dùle¾itý mechanismus OOJ, který obohacuje mo¾nosti polymorfismu a dìdiènosti, nìkteré OOJ umo¾òují tuto mo¾nost pomocí klíèového slova\footnote{V Javì, PHP je to klíèové slovo \texttt{final}, zaká¾e jakoukoliv modifikaci metody/promìnné/tøídy} zakázat.

			\paragraph{\texttt{Self / this}} V ka¾dém OOJ je implicitnì nebo explicitnì oznaèen objekt pøíjemce zprávy. Slou¾í k referencování pøíjemce v kontextu právì vykonávané metody. Implicitní pøedávání pøíjemce zprávy metodì se vìt¹inou realizuje nultým skrytým parametrem této metody\footnote{U Pythonu se metody tøídy definují s prvním parametrem \texttt{self}, v C\# se jedná právì o skrytý nultý parametr}.
			\paragraph{\texttt{Super / base}} V pøípadì, kdy potøebujeme vyu¾ít kód ji¾ definované metody, odká¾eme se na metodu definovanou v rodièovské tøídì pøes klíèová slova \texttt{base} nebo \texttt{super} s pøedáním potøebných parametrù\footnote{V pøípadì, ¾e rodiè obsahuje \texttt{metoda(int par, String par2)}, tak v metodì potomka voláme \texttt{super(par, par2)}, kde za hodnoty parametrù dosadíme ty, které chceme vyu¾ít}. Pøi vícenásobné dìdiènosti musíme specifikovat konkrétní tøídu\footnote{V C++ \texttt{A::metoda()}, kde A je tøída, ze které bude metoda volaná}, tzv. klasifikace jména.

			\paragraph{Èasná vazba} Pøi pøekladu programu nemusí být mo¾né správnì odhadnout s jakým typem objektu budeme pracovat.
			\paragraph{Pozdní vazba} K identifikaci potøebné metody se pøistupuje a¾ v dobì bìhu programu, kdy by mìlo dojít k její invokaci. Provádí se pøes tabulky virtuálních metod (VMT), ka¾dá instance tøídy obsahující virtuální metody se odkazuje na VMT.
			U dynamicky typovaných OOJ jsou v¹echny metody virtuální, v¹echny objekty toti¾ obsahují reference na tøídu, které je objekt instancí, nikoliv pouze data.

		\subsubsection{Prototypovì orientované jazyky}
			Tyto jazyky unifikují svùj návrh tím, ¾e znají pouze jediný typ objektù a nevyèleòují samostatnì objekty reprezentující tøídy. Ka¾dý objekt mù¾e obsahovat jek èlenské promìnné tak metody. Tyto slo¾ky objektu se oznaèují jako sloty.

			\paragraph{Sdílené chování} Pokud je objektu zaslaná zpráva, prozkoumá mno¾inu svých slotù a pokusí se najít ten, který poslané zprávì odpovídá.

			\paragraph{Klonování} Nové objekty se vytváøejí kopírováním existujících objektù, tzv. klonováním. Implicitnì se provádí technikou mìlkého kopírování. Teoreticky v¹ak mù¾e ka¾dý objekt pøesnì definovat v¹echny své operace, tzn. v¹echny pøíbuzné objekty by pou¾ívaly své nezávislé kopie metod \tedy pøi zmìnì kódu metody jednoho objektu by nedo¹lo ke zmìnì korespondujících metod v objektech dal¹ích.

			\paragraph{Delegace} je proces velmi podobný obyèejnému zaslání zprávy, narozdíl od nìj ale pøi invokaci metody v delegovaném objektu nemìní kontext. Pokud je zpráva delegována na jiný objekt, je v tomto objektu nalezen odpovídající slot a pokud je tímto slotem metoda, je spu¹tìn její kód s tím, ¾e ukazatel na pøíjemce zprávy neodkazuje na delegovaný objekt, ale na objekt, který delegaci provedl.

			\paragraph{Rodièovský slot} Pokud je objektu poslána zpráva a ten ve svých slotech nenalezne ¾ádný vhodný, provede delegaci zprávy na objekty, které jsou odkazovány speciálním typem slotù \tedy rodièovské sloty. Pokud ani rodièovský slot neobsahuje vhodný slot, deleguje zprávu dále na rodièovské sloty. Reference na pøíjemce zprávy zùstává na pùvodním pøíjemci.

			\paragraph{Dìdiènost\,--\,rysy} Objekty, které obsahují sdílené chování a tím nahrazují nebo doplòují tøídy, se oznaèují rys. Provázáním jednotlivých rysù rodièovskými sloty lze dosáhnout obdoby dìdiènosti.
			Nìkteré jazyky umo¾òují umístit do objektù více rodièovských slotù, doká¾í tak elegantnì vytvoøit obdobu vícenásobné dìdiènosti.

			Dynamická dìdiènost \tedy schopnost mìnit hodnoty v rodièovských slotech.

			\paragraph{Prototypy} pro plnou náhradu tøíd pouze rysy nestaèí. Je potøeba vyøe¹it problém s instanèními promìnnými, které jsou souèástí samotných objektù a ka¾dý objekt musí mít jejich samostatnou kopii.
			\begin{itemize}
				\item Nìkteré jazyky instanèní promìnné pøidávají do objektu a naplòují je standardními hodnotami v konstruktoru rysu
				\item Doplnit rys je¹tì jedním objektem, který obsahuje sloty instanèních promìnných s implicitními hodnotami a ve svém rodièovském slotu odkazuje rys. Nová instance se pak vytvoøí nakopírováním této ¹ablony \tedy ¹abloby instancí se oznaèují jako prototypy
			\end{itemize}

		\subsubsection{UML}
		Jednotný grafický (vizuální) jazyk pro jednotnou specifikaci, vizualizaci, konstrukci a dokumentaci pøi objektovì orientované analýze a návrhu i pro modelování organizace.

		\paragraph{Pohled} projekce systému na jeden z jeho klíèových aspektù a znazoròujeme jej jedním èi více diagramy UML. Základní pohledy jsou strukturální, datový, pohled na chování a rozhraní. Pohledy resp. diagramy lze rozdìlit:
		\begin{itemize}
			\item Analytické \tedy co bude systém dìlat
			\item Návrhové \tedy jak to bude dìlat
		\end{itemize}
		\paragraph{Diagram UML} je struktura podobná obecnému grafu obsahujícímu mno¾inu grafických prvkù propojených vztahy.

		Stavební bloky UML jsou:
		\begin{itemize}
			\item[1.] Prvky \tedy pøedmìty, entity, abstrakce
			\begin{itemize}
				\pojem{Strukturní}{tøída, pøípad pou¾ití, komponenta}
				\pojem{Chování}{interakce, stav}
				\pojem{Seskupování}{modul, balíèek, podsystém}
				\pojem{Doplòkové}{komentáøe a poznámky}
			\end{itemize}
			\item[2.] Vztahy \tedy mezi prvky
			\begin{itemize}
				\pojem{Asociace}{spojení mezi prvky}
				\pojem{Závislost}{zmìna v jednom prvku ovlivní jiný závislý prvek}
				\pojem{Agregace, Kompozice}{vyjádøení dekompozice prvku na podèásti}
				\pojem{Generalizace}{vztah mezi obecnìj¹ím a specifiètìj¹ím prvkem}
				\pojem{Realizace}{vztah mezi pøedpisem a jeho uskuteènìním}
			\end{itemize}
		\end{itemize}
		Modely:
		\begin{itemize}
			\item[a.] Model struktury (statický aspekt modelu) \tedy popisuje entity systému a jejich souvislostí
			\begin{itemize}
				\item Diagram tøíd
				\item Diagram komponent
				\item Diagram rozmístìní zdrojù
			\end{itemize}
			\item[b.] Model chování (dynamický aspekt modelu)\tedy popisuje ¾ivotní cyklus entit a jejich spolupráci
			\begin{itemize}
				\item Diagram objektù
				\item Diagram pøípadù pou¾ití
				\item Diagram interakce: diagram sekvence, diagram spolupráce
				\item Stavový diagram
				\item Diagram aktivit
			\end{itemize}
		\end{itemize}

		\paragraph{Diagramy tøíd a objektù} Reprezentace tøíd a objektù v UML je následující:
		
		\textbf{Tøída} je rozdìlena na tøi bloky obsahující název, seznam atributù a seznam operací.\\

		\textbf{Objekt} obsahuje pouze podtr¾ený identifikátor objektu s pøípadným urèením tøídy a seznamu atributù s pøiøazenými hodnotami.\\

		\textbf{Atributy} jsou prvky objektu u nich¾ lze specifikovat typ, jméno, impicitní hodnotu a viditelnost.\\

		\textbf{Operace} ve vìt¹inì pøípadù odpovídají metodám tøídy a jedná se o pojmenované chvání tøídy. Jsou popsány identifikátorem, modifikátorem viditelnosti, seznamem formálních parametrù a návratovým typem. Ka¾dý parametr mù¾e obsahovat V/V modifikátor (\texttt{in} pro vstupní, \texttt{out} pro výstupní a \texttt{inout} pro vstupnì-výstupní parametry), formální jméno a typ.

		UML poskytuje i typy viditelnosti atributù nebo operátorù:
		\begin{itemize}
			\item[-] Soukromá viditelnost \tedy atribut/operace je k dispozici pouze uvnitø tøídy, kde je definován(a)
			\item[\#] Chránìná viditelnost \tedy pøístup je omezen pouze na instance tøíd pøímo èi nepøímo zdìdìných od vlastníka atributu/operace
			\item[$+$] Veøejná viditelnost \tedy k atributu/operaci lze pøistupovat bez omezení z libovolného jiného objektu
		\end{itemize}

		\textbf{Tøídní atributy a operace} jsou znaèeny podtr¾ením\footnote{POZOR! stejné jako u identifikátoru objektu, ale není to toté¾}\\

		\textbf{Abstraktní operace a tøída}, u kterých není nutné mít v dané tøídì implementace ale pouze definici, jsou znaèeny kurzívou. Stejnì tak i u abstraktní tøídy. Nìkdy se pou¾ívá klíèové slovo \texttt{abstract} pøed název tøídy.

		\paragraph{Stereotypy tøíd} oznaèení speciálního druhu tøídy se specifickým úèelem. Bývá zapisován nad název tøídy do francouzských uvozovek (\texttt{$\ll$stereotyp$\gg$})

		Èasto se v OOP setkáváme s tøídami, které nejsou primárnì urèeny pro popis atributù a operací jejích instancí, ale pro sdru¾ení obecnì pou¾ívaných funkcí. Takovýto význam tøídy zapisujeme stereotypem \texttt{$\ll$utility$\gg$}, neboli balíèek nástrojù. \\
		V praxi se z této tøídy nevytvoøí instance (v¹echny èleny má statické) nebo se vytváøí jediná instance (singleton).\\

		\textbf{Stereotyp rozhraní} slou¾í pro popis speciální tøídy, která slou¾í pro sdru¾ení mno¾iny operací, jejich¾ rozhraní vyvá¾í ostatním tøídám, které toto chování pak povinnì implementují. 
		
		\paragraph{Parametrizovaná tøída (generická tøída, tøída ¹ablony)} uvnitø pracují s jedním nebo více v dobì psaní kódu neznámými datovými typy nebo tøídami.
		Tøída mù¾e dále obsahovat textové i grafické poznámky, klíèová slova, stereotypy a dodateèné informace pro dokumentaèní úèely.
		
		\paragraph{Diagram tøíd} je graf symbolù tøíd, rozhraní, seskupení a dal¹ích strukturních prvkù propojených statickými vztahy (asociace, závislost, agregace, kompozice, generalizace, realizace)\\

		\textbf{Násobnosti vztahu} se udávají pro upøesnìní obecného vztahu a bývají znaèeny na obou koncích úseèky, která znázoròuje vztah mezi tøídami A a B. Násobnost b v pøípadì diagramu tøíd odpovídá na otázku "S kolika objekty tøídy B je v relaci jeden objekt tøídy A?" a analogicky pøesnì naopak se dotazujeme na násobnost a.
		\begin{enumerate}
			\item Konstanta $k$
			\item Libovolné neomezenì velké nezáporné celé èíslo
			\item Interval slo¾ený z konstanty urèující dolní hranici $D$ a horní hranici $H$, kdy platí $D < H$ nebo $H$ mù¾e být $*$ (napø. $0..*$ pro libovolnou násobnost a $0..1$ pro volitelnost, apod.).
		\end{enumerate}

		\textbf{Asociace} je obecná relace mezi dvìma èi více tøídami zakreslená úseèkou spojující tyto tøídy. Asociace mù¾e být pojmenována pro upøesnìní svého významu. Oba konce mohou obsahovat popis role pøipojené tøídy.\\

		\textbf{Realizace} je vztah mezi rozhraním a implementaèní tøídou, který znaèíme èárkovanou ¹ipkou smìøující k rozhraní.\\

		\textbf{Generalizace} je statický vztah mezi obecnìj¹í a specifiètìj¹í entitou, v pøípadì tøíd mezi rodièovskou tøídou a tøídou potomka.\\

		\textbf{Agregace} vyjadøuje slo¾ení entity ze skupiny komponentních entit. Vztah kreslíme jako úseèku na stranì celku zakonèenou prázdným kosoètvercem a na druhém konci ¹ipkou s pøípadnou násobností.\\

		\textbf{Kompozice} je speciální pøípad agregace, kdy ka¾dá komponentní tøída smí nále¾et pouze jednomu celku. Na rozdíl od agregace zakreslujeme na stranì kompozitní tøídy vyplnìný kosoètverec.\\

		\textbf{Závislost} je vztah mezi prvky, v ní¾ zmìna jednoho elementu má vliv na závislý element. Vyu¾ívá se pøedev¹ím pro vyjádøení závislostí, je¾ nejsou asociací a znaèí se pøeru¹ovanou ¹ipkou od klienta k dodavateli.

		\paragraph{Diagram objektù} ukazuje objekty a jejich propojení, vèetnì idenitifikace vyznaèených objektù v urèitém èase. Pou¾ívá se i pro ovìøení korektnosti diagramu tøíd, za její¾ instanci lze diagram objektù pova¾ovat.

		\paragraph{Diagramy seskupení, komponent a zdrojù} jsou novì zavedeny èi upraveny v UMLv2:
		
		\textbf{Diagram seskupení} je vhodný pøedev¹ím pro modelování rozsáhlých systémù a prezentací vazeb mezi jeho podsystémy a dal¹ími moduly. Seskupení je prvek diagramu, který doká¾e obalit a zapouzdøit libovolnou mno¾inu entit, pro kterou to dává významový smysl, za úèelem zpøehlednìní vazeb mezi tìmito mno¾inami.\\

		\textbf{Diagram komponent} ukazuje strukturu komponent systému a závislosti mezi nimi. Komponenta je pøístupná pouze prostøednictvím svého rozhraní a je dána svými klasifikátory a artefakty. Je velmi blízký samotné implementaci a bývá èasto vyu¾íván pro dokumentaci nebo odhalení správného poøadí kompilace komponent systému a zároveò tøíd, které tuto komponentu implementují.\\

		\textbf{Diagram rozmístìní zdrojù} poskytuje pohled na fyzické rozmístìní systému, který je v tomto diagramu reprezentován pomocí uzlù propojených komunikaèními cestami. Uzel je v tomto grafu výpoèetním zdrojem rozdìleným na procesor a zaøízení.
		
		\paragraph{Diagram pøípadù pou¾ití} graficky znázoròuje úèastníky, pøípady pou¾ití, interakce a hranice systémù. \\
		Pomocí stereotypù \texttt{$\ll$use$\gg$}(implicitní), \texttt{$\ll$include$\gg$} a \texttt{$\ll$extend$\gg$} lze upøesnit vztahy mezi samotnými pøípady u¾ití.

		\paragraph{Diagram datových tokù} je hierarchický model pou¾ívaný pøi strukturované analýze a návrhu pro specifikaci chování systému. Oproti objektovì orientovanému diagramu pøípadù pou¾ití je blí¾e návrhu, proto¾e obsahuje i informace o datech.

		\paragraph{Diagramy interakce} popisují komunikaèní strukturu v dobì bìhu modelovaného systému a jsou reprezentovány diagramem spolupráce a diagramem sekvence.\\

		\textbf{Diagram spolupráce} popisuje objekty propojené pomocí posílání zpráv mezi tìmito objekty.\\

		\textbf{Diagram sekvence} zdùrazòuje èasovou posloupnost vztahù mezi objekty. V nìkterých pøípadech jej lze vyu¾ít pro detailnìj¹í popis vybraného pøípadu pou¾ití.
		

		\paragraph{Stavový diagram} se vá¾e v¾dy na konkrétní tøídu a ukazuje stavy, do kterých mohou její instance vstupovat, a pøechody mezi nimi. Pøi pokroèilej¹ím modelování tyto diagramy umo¾òují popisovat vnoøené stavy, pou¾ívané zprávy i s argumenty, soubì¾nost a synchronizaci.


		\subsubsection{Vlastnosti OOJ}
		\paragraph{Ortogonalita} Konkrétnì v textu o programovacích jazycích chápeme ortogonalitu jako nezávislost vlastnosti jazyka na programovacím paradigmatu. \\
		Napøíklad ¹ablony a výjimky jako technologie jsou ortogonální vùèi objektovì orientovanému paradigmatu, z èeho¾ plyne, ¾e je lze uplatnit i v jazycích, je¾ nejsou objektovì orientované.

		\paragraph{Klasifikace jazykù} podle nìkolika významných kritérií:
		\begin{enumerate}
			\item Podle urèování typù pøi zápisu programu
			\item Podle doby vytvoøení vazby promìnné na typ
			\item Podle zpùsobu typové kontroly
			\item Podle dùkladnosti typové kontroly
		\end{enumerate}

		\paragraph{Pojmy}
		\begin{itemize}
			\pojem{Datový typ}{popisuje reprezentaci, interpretaci a pøedev¹ím strukturu datový typ hodnot pou¾ívaných algoritmy nebo objekty v pamìti poèítaèe}
			\pojem{Typový systém}{vyu¾ívá typové informace k ovìøení korektnosti poèítaèových programù pøi jejich práci s daty}
			\pojem{Typová chyba}{ohlá¹ení chyby, která oznaèuje pou¾ití nepovolených/nekompatibilních/nevhodných typù operandù pøi libovolné operaci}
			\pojem{Silná kontrola}{typ kontroly, kdy jsou v¾dy detekovány v¹echny typové chyby, co¾ vy¾aduje schopnost urèit typy v¹ech operandù, a» ji¾ pøi kompilaci nebo pøi bìhu programu}
		\end{itemize}

		\paragraph{Klasifikace jazykù}
		\begin{itemize}
			\item \textbf{Podle urèování typù pøi zápisu programu}
			\begin{itemize}
				\pojem{Beztypové}{bez typù, v podstatì se jedná pouze o teoretické a formální jazyky nebo jazyky s jediným univerzálním typem (napø. $\varsigma$-kalkul a $\lambda$-kalkul)}
				\pojem{Netypové}{ve zdrojovém kódu nemá promìnná urèený typ a tuto informaci nemá programátor k dispozici, interpret/kompilátor zaji¹»uje implicitní typové konverze automaticky}
				\pojem{Typované}{typ je urèen ve zdrojovém programu u ka¾dé entity. Promìnná mù¾e mít typ urèen explicitnì nebo odvozením (typová inference), kdy je výsledný typ výrazu odvozen z typù jeho operandù a samotných operací}
			\end{itemize}
			\item \textbf{Podle doby vytvoøení vazby promìnné na typ}
			\begin{itemize}
				\pojem{Staticky typované}{pøed bìhem programu, tj. v dobì návrhu kompilátoru, kompilace programu èi zavádìní programu}
				\pojem{Dynamicky typované}{typ promìnné je urèen a¾ za bìhu programu, v¹echny promìnné obsahují objekty, ale konkrétní typ zále¾í a¾ na konkrétních pøiøazených instancích}
			\end{itemize}
			\item \textbf{Podle zpùsobu typové kontroly}
			\begin{itemize}
				\pojem{Statická typová kontrola}{vìt¹ina typových kontrol je provádìna bìhem pøekladu}
				\pojem{Dynamická typová kontrola}{ve¹keré typové kontroly mohou být provádìny a¾ za bìhu programu, co¾ v¹ak ovlivòuje i výkon programù v tìchto jazycích a èasto vy¾adují bìh na vituálním stroji}
			\end{itemize}
			\item \textbf{Podle dùkladnosti typové kontroly}
			\begin{itemize}
				\item Silnì typované jazyky
				\begin{itemize}
					\item \textbf{Témìø silnì typované jazyky}\footnote{Napø. Java nebo Ada} u nich¾ existuje mo¾nost jak implicitnì zpùsobit typovou chybu/nekonzistenci s výjimkou explicitní typové konverze s vypnutou typovou kontrolou
					\item \textbf{Støednì silnì typované jazyky}\footnote{Napø. ML}
					\item \textbf{Absolutnì silnì typované jazyky} jsou silnì typované a neobsahují naprosto ¾ádné implicitní konverze\footnote{Napø. Smalltalk nebo SELF}
				\end{itemize}
				\item \textbf{Slabì typované jazyky} jsou jazyky, kde je mo¾né i po úspì¹né kompilaci dojít k typové chybì, dokonce velmi slabì typované jazyky\footnote{C/C++} umo¾òují kromì volnìj¹í práce s variantním typem (union) i mo¾nost nekotrolovat typy parametrù funkcí/metod a dal¹í typové prohøe¹ky
			\end{itemize}			
		\end{itemize}

		\subsubsection{Vlastnosti tøídních jazykù}
		\paragraph{Øízení toku programu} Je nutné zachování starých konstrukcí ze strukturovaných a modulárních jazykù a pøidat nim mechanismus zasílání zpráv. Výhodou je pozvolnìj¹í pøechod z modulárních jazykù na objektové orientované, ov¹em je rizikem, ¾e se u¾ivatel mù¾e nauèit ¹patném objektovému my¹lení \tedy lep¹í je si vyzkou¹et èistì objektový jazyk.

		\paragraph{Jmenný prostor (namespace)} je z programátorského hlediska kontejner pro identifikátory (èi jiné entity jazyka). Uvnitø se nevyskytují ¾ádné dva stejné identifikátory. V UML modelováno jako seskupení. \\
		Dùvodem zavedení je zabránìní kolizím jmen v rozsáhlých zdrojových textech.

		\paragraph{Modifikátor viditelnosti} je mechanismus pøítomný v mnoha dne¹ních OOJ, který má za úkol mìnit mo¾nost pøístupu k rùzným entitám jazyka, a tak podrobnìji konfigurovat koncept zapouzdøení.
		\begin{itemize}
			\pojem{Soukromý -- \texttt{private}}{atributy èi metody jsou pøístupné pouze z metod stejné tøídy}
			\pojem{Chránìný -- \texttt{protected}}{atributy èi metody jsou dostupné pouze z metod stejné tøídy a tøíd tuto tøídu dìdících}
			\pojem{Veøejný -- \texttt{public}}{atributy èi metody jsou dostupné odkudkoliv}

			\item \texttt{internal}: veøejná viditelnost pouze uvnitø domovského jmenného prostoru
			\item \texttt{friend}: mo¾nost pøistupovat k soukromým entitám v pøípadì tzv. spøátelených, které jsou v blízkém závislostním vztahu
		\end{itemize}
		Nìkteré jazyky urèují viditelnost napevno \tedy soukromá viditelnost atributù a veøejná viditelnost v¹ech metod v jazyce Smalltalk
		
		\paragraph{Pøetì¾ování metod} je vlastnost umo¾òující definovat ve tøídì více metod se stejným jménem. Jediným po¾adavkem bývá, aby se metody odli¹ovaly v typech nebo poètu parametrù. Kromì pøetì¾ování metod se nìkdy umo¾òuje pøetì¾ovat i operátory (unární i binární), co¾ ov¹em nemusí být za v¹ech okolností vhodné.

		\paragraph{Vícenásobná dìdiènost} v definici pøedkù dané tøídy mù¾e být uvedená i více jak jedna tøída. Tento typ dìdiènosti má více nevýhod ne¾ výhod:
		\begin{itemize}
			\item Opravdu oprávnìné a správné pou¾ití je velmi ojedinìlé (èasto svádí k chybám v návrhu)
			\item Efektivní implementace patøí mezi pokroèilej¹í problémy návrhu OOJ
		\end{itemize}
		Pøekladaè OOJ musí øe¹it tyto problémy:
		\begin{enumerate}
			\item Rodièovské tøídy mohou obsahovat èleny stejného jména i typu
			\item Nebo jen stejného jména rùzného typu
			\item Poøadí volání konstruktorù, pøípadnì destruktorù
			\item Ulo¾ení objektu tøídy C v pamìti tak, aby jej bylo mo¾no vyu¾ít kdekoli je oèekáván objekt tøídy A, B nebo C\footnote{Byly definovány tøídy A, B a tøída C, která obì pøedchozí dìdila}
		\end{enumerate}

		\paragraph{Návrhy øe¹ení nìkterých problémù vícenásobné dìdiènosti}
		\begin{itemize}
			\item[1)] Kolize metod stejného jména i typu v nové tøídì lze øe¹it:
			\begin{itemize}
				\item[a)] Sémantickými kontrolami zakázat tuto mo¾nost ji¾ pøi kompilaci zdrojového kódu
				\item[b)] Do¾adovat se v pøípadì kolize upøesnìní, ve které tøídì volanou metodu hledat
				\item[c)] Vy¾adovat povinnou reimplementaci, co¾ má ov¹em svá úskalí
			\end{itemize}
			\item[2)] Kolize metod se stejným jménem, ale rùzným návratovým typem u nové tøídy, kde:
			\begin{itemize}
				\item[a)] Tento pøípad se zaká¾e podobnì jako v pøedchozím pøípadì
				\item[b)] Povolí se existence obou metod ov¹em pouze v pøípadì, ¾e daný jazyk umo¾òuje pøetì¾ování, co¾ kromì pøekladu zvy¹uje i re¾ii u pomocných rutin za bìhu programu
			\end{itemize}
			\item[1 a 2)] Atributy stejného jména i typu jsou øe¹eny analogicky k problému s metodami. Pouze v pøípadì stejnì pojmenovaných atributù jiných typù se zatím nepodaøilo úspì¹nì implementovat pøetì¾ování, tak¾e se tato kombinace zpravidla zakazuje.
			\item[3)] Problém s inicializací se týká poøadí volání konstruktorù (metody slou¾ící pro inicializaci objektù pøi jeho vytváøení), je¾ jsou automaticky spou¹tìny nejen z tøídy daného objektu, ale vìt¹inou i z rodièovských tøíd
			\begin{itemize}
				\item[1.] Vyu¾ít poøadí zápisu tøíd ve zdrojovém textu, v jakém byly v seznamu rodièovských tøíd instanciované tøídy uvedeny
				\item[2.] Ignorování zápisu ve zdrojovém textu, ale vyu¾ití u¾ivatelem definovaného poøadí inicializace, které ov¹em není dodateènì kontrolováno na pøípadné uváznutí èi nesprávné poøadí.
			\end{itemize}
			\item[4)] Ani pro zpùsob ukládání objektù v OOJ s vícenásobnou dìdièností neexistuje jedno univerzální a obecné øe¹ení, které navíc vìt¹inou silnì závisí na vlastnostech daného jazyka. Typicky lze ukládat èleny jednotlivých tøíd v objektu do bloku podle tøíd a v pøípadì kolize jmen vytvoøit duplikát daného èlena v obou pøíslu¹ných blocích. Pøi oèekávání rodièovské struktury u takovéhoto objektu je v¹ak tøeba zajistit synchronizaci obsahù duplikovaných atributù.
		\end{itemize}

		\paragraph{Rozhraní} Výhodou vícenásobné dìdiènosti oproti jednoduché je mo¾nost sdílení protokolu napøíè hierarchií dìdiènosti, tj. i u tøíd z rùzných vìtví stromu dìdiènosti lze syntakticky zaruèit existenci patøièného podprotokolu. Nevýhodou je problém s kolizí rùzných implementací pro stejnì pojmenované metody. Zachováním popsané výhody a vylouèením nevýhod dostáváme mechanismus rozhraní (interface), který je schopen s jistými omezeními zcela nahradit vícenásobnou dìdiènost.

		Rozhraní je schéma, které deklaruje seznam metod. Pou¾ití rozhraní na jistou tøídu pak vynucuje implementaci v¹ech metod uvedených v rozhraní. I v pøípadì jednoduché dìdiènosti lze ka¾dé tøídì uvést nìkolik rozhraní.

		Implementace rozhraní je jednodu¹¹í ne¾ v pøípadì vícenásobné dìdiènosti, pøesto je v pøípadì kombinace s jednoduchou dìdièností nutno zvolit nejvhodnìj¹í implementaci:
		\begin{itemize}
			\item[a)] Vázání pøes jméno rozhraní \tedy nikoliv pøes adresu, nutno provádìt za bìhu a èasto s podporou virtuálního stroje
			\item[b)] Nìkolik tabulek virtuálních metod \tedy poøadí je dáno zápisem rozhraní ve zdrojovém textu
			\item[c)] Metody \texttt{get/set} \tedy slou¾í k získání adres kódu metody zadaného jména
		\end{itemize}

		\paragraph{Výjimky} Moderní zpùsob o¹etøování chybových a neoèekávaných stavù vykonávaného programu je vyu¾ití výjimek, co¾ je mechanismus, který popisuje zpùsob ¹íøení informace o chybì, zpùsob zastavení/pøeskoèení výpoètu a umo¾òuje provést o¹etøení chyby a¾ za samotným algoritmem a tím zlep¹it èitelnost kódu i samotného algoritmu.

		Umo¾òuje finalizaèní sekce, její¾ provedení je garantováno i v pøípadì vyvolání výjimky.

		Pøi vyvolání výjimky uvnitø try-bloku (pøíkazem èi zprávou \texttt{rise} nebo \texttt{throw}) je proveden skok na zaèátek catch-bloku a na jeho formální parametr je navázán vzniklý objekt výjimky. V o¹etøovacím kódu je pak vìt¹inou potøeba zjistit, jaké tøídy výjimka je, abychom vìdìli, jak s ní nalo¾it.

		\paragraph{©ablony} Mohou být implementovány:
		\begin{itemize}
			\item Staticky -- ¹ablona je zpracována a vyu¾ívána pouze pøi kompilaci zdrojového kódu, v podstatì se jedná o velmi sofistikované roz¹íøení preprocesoru jazyka
			\item Dynamicky -- nejèastìj¹i pomocí virtuálních funkcí resp. metod, co¾ vy¾aduje dodateènou re¾ii za bìhu programu
			\item Ad hoc -- pøedem a napevno definované pøetì¾ování operátorù pro omezený poèet typù (+ pro sèítání i pro konkatenaci)
		\end{itemize}

		©ablona je mechanismus, který umo¾òuje parametrizaci definic datových typù. V definici nového ¹ablonového typu potom daný parametr vyu¾íváme jako promìnnou, která obsahuje identifikaci jiného typu. ©ablony mohou obsahovat i více parametrù.


		\paragraph{Systémy s rolemi} V pøípadì objektu, který pøetrvává v systému dlouhou dobu a postupnì se vyvíjí a je potøeba tomu pøizpùsobovat i schopnosti (protokol) tohoto objektu. Objekt tedy mù¾e pøebírat konkrétní roli, mù¾e bìhem svého ¾ivota v systému s rolemi vystupovat pod rùznými rolemi, které mù¾e postupnì nabývat nebo pozbývat.

		Objekt s více typy je objekt, který mù¾e mít v jeden okam¾ik více typù. Pùvod tohoto pojmu je v objektovì orientovaných databázích, kde pak hovoøíme o rolích objektu.

		Vícenásobná dìdiènost by nestaèila proto¾e:
		\begin{enumerate}
			\item Je mo¾né velké mno¾ství kombinací, které vy se velmi tì¾ko udr¾ovalo
			\item Nelze pøedpovídat jaké dal¹í role bude nutné dotvoøit v prùbìhu provozování samotného systému
		\end{enumerate}

		Systémy s rolemi pou¾ívají vìt¹inou perzistentní objekty. Jsou vìt¹inou interpretované systémy, ked je potøeba provádìt asociaci objektu a role za bìhu. 

		\paragraph{Perzistentní objekty} Objekt, který pøe¾ívá rámec aplikace a pøi dal¹ím spu¹tìní aplikace je tentý¾ objekt opìt k dispozici v pøesnì stejném stavu jako mìl pøi posledním ukonèení aplikace.

		Perzistence ale není jenom snímek objektové pamìti, explicitní ukládání a naèítání dat pro rekonstrukci objektù také nepova¾ujeme za perzistenci.

		Implementace perzistentních objektù:
		\begin{itemize}
			\item[a)] Ukládat pouze stav objektu -- metody objektu musí být dosa¾itelné jiným zpùsobem, z teoretického pohledu se v¹ak nejedná o plnohodnotnou perzistenci, jeliko¾ lze pohodlnì zajistit knihovnami pro ukládání a naèítání stavù objektù
			\item[b)] Ukládat stav objektu i jeho metody -- proto¾e na kompilovaných systémech je tøeba v tomto pøípadì øe¹it mnoho problémù, provádí se pouze pøeklad do mezikódu, jen¾ je následnì interpretován virtuálním strojem
		\end{itemize}

		\subsubsection{Poznámky k implementaci OOJ}
		Pøi pou¾ívání von Neumannovy architektury poèítaèù, kdy nemáme k dispozici nic jako èistì objektovou pamì» nebo mechanismus zasílání a smìrování zpráv. Znaèné mno¾ství moderních OOJ øe¹í tyto nevýhody vytvoøením tzv. virtuálního stroje, který vytváøí pro jazyk interpretaèní nebo pseudopøekladové prostøedí obsahujcící objektovou pamì» i snadnìj¹í práci se zprávami.

		\paragraph{Manipulace se tøídami} V pøípadì hybridního objektového pøístupu se pro ukládání atribudu nabízí vyu¾ití datových struktur, jak je známe ze strukturovaných jazykù. Problémem je nedostateèná variabilita takovéto struktury, která je pro ukládání nìkterých objektù nezbytná.
		Problémy, které je nutno vyøe¹it:
		\begin{itemize}
			\item Ukládání metod
			\item Dìdiènost
			\item Pøístup k atributùm v metodách
			\item Instanèní a tøídní promìnné, instanèní a tøídní metody
		\end{itemize}
		
		Øe¹ení:
		\begin{itemize}
			\item Statické metody a promìnné nejsou ulo¾eny v objektu ani VMT (u nich neexistuje v takovéto implementaci ¾ádný polymorfismus)
			\item Instance tøídy B má dostupné jak svoje metody, tak metody v¹ech pøedkù. VMT je implementována jako dynamická struktura a tedy obsahuje pouze reference na skuteèný kód daných metod.
		\end{itemize}

		\paragraph{Virtuální stroj} je speciální softwarová vrstva, její¾ primárním úèelem je odstínit pro bì¾ící aplikaci hardwarová specifika poèítaèe, na nìm¾ je vykonávána. Do toho zahrnujeme i proces samotného vykonávání kódu, díky èemu¾ je dosa¾eno naprosté nezávislosti na konkrétní platformì.

		Virtuální stroje volí jeden z následujících pøístupù k vykonávání kódu:
		\begin{itemize}
			\item Pøímá interpretace kódu ze syntaktického stromu zdrojového kódu
			\item Kompilace do mezikódu a jeho následná pøímá interpretace
			\item Kompilace do mezikódu, jeho následný pøeklad do nativního strojového kódu a vykonání (SELF, Java)
		\end{itemize}

		Jako mezikód se pou¾ívá tzv. bytekód, co¾ je binární forma mezikódu s èlenìním po bytech. Je nezávislý na platformì, je rychlej¹í ne¾ pøímá interpretace a nevy¾aduje pøekladaè jako souèást virtuálního stroje.\\

		\textbf{Práce s pamìtí} hraje zásadní roli u virtuálního stroje, u OOJ nechápeme pamì» jako sekvenèní prostor pro ukládání dat, ale pøímo jako mno¾inu objektù.\\

		\textbf{Garbage Collector} zaji¹»uje odmazávání nepotøebnných ji¾ neodkazovaných objektù. Implementace kvalitního GC není triviální zále¾itost a vìt¹inou se v nìm kombinuje nìkolik implementaèních strategií.

		Nìkteré jazyky umo¾òují pou¾ívat tzv. obrazy objektové pamìti, pøi spu¹tìní programu pak nedochází k postupné inicializaci objektù podle pokynù programu, ale je obnoven naposledy ulo¾ený stav. \\

		\textbf{Nevýhoda virtuálního stroje} je podstatnì vy¹¹í re¾ie, ne¾ u nativních programù, stejnì tak i odstup od hostitelského systému.



		\paragraph{Návrhové vzory} jsou obecná znovupou¾itelná øe¹ení èasto se vyskytujících problémù v programovém návrhu. Jedná se o popis postupu nebo ¹ablonu, pomocí které pohodlnì daný problém správnì a efektivnì vyøe¹íme.

		Návrhnový vzor systematicky nazývá, vysvìtluje a vyhodnocuje dùle¾itý a v objektovì orientovaných systémech se opakující návrh.

		Lze je zevrubnì rozdìlit následovnì:
		\begin{enumerate}
			\item Vytváøecí vzory -- nepøímou cestou pro nás vytváøí objekty, ani¾ bychom je museli vytváøet pøímo a poskytuje nám tak vìt¹í flexibilitu programu
			\item Strukturální vzory -- napomáhají pøi shlukování objektù do vìt¹ích celkù, jako napøíklad komplexní u¾ivatelské rozhraní apod.
			\item Vzory chování -- pomáhají pøi definici komunikace mezi objekty v systému a tomu øízení ve slo¾itìj¹ích programech
		\end{enumerate}

		\textbf{Jedináèek (singleton)} je návrhový vzor, který omezuje mo¾nosti vytváøet z tøídy víze jak jednu instanci. Bývá nejèastìji implementován pomocí veøejnì statické metody, soukromé statické promìnné a zakázáním volání konstruktoru z ostatních tríd.


		\subsubsection{Zpracování\,--\,analýza, vyhodnocení, interpretace a pøeklad}
		Pøi zpracování objektovì orientovaného jazyka máme tøi mo¾nosti:
		\begin{enumerate}
			\item Provést pøeklad zdrojového textu do samostatného modulu, který obsahu pøímo instrukce daného procesoru \tedy výsledkem je nativní aplikace, podobná tìm co dostáváme jako výsledek pøekladu vìt¹iny strukturovaných a modulárních jazykù
			\item V pøípadì èistých objektovì orientovaných jazykù potøebujeme mít pro objektový program k dispozici pamì», která se chová jako objektová a také instrukce pro zasílání zpráv. Je nutné vytvoøit vrstvu mezi procesorem a na¹ím objektovì orientovaným programem \tedy vzniká virtuální stroj, pøekladaè pak provádí transformaci zdrojového textu na kód, kterému rozumí onen virtuální stroj
			\item Poslední mo¾ností je èistá implementace zdrojového kódu bez pøekladu, která je v¹ak neefektivní a vyu¾ívá se spí¹e výjimeènì	
		\end{enumerate}

		\paragraph{Pøekladaè} U tøídnì zalo¾ených OOJ se ka¾dá tøída ukládá do zvlá¹tního souboru, kvùli tomuto pøístupu je pøekladaè OOJ minimálnì tak slo¾itý jako pøekladaè modulárních jazykù, kdy musel být schopen vytvoøit graf závislosti pro pøeklad jednotlivých tøíd a poté je je¹tì lineárnì uspoøádat.
		Dal¹í nezbytností je vyu¾ívání lokálních tabulek symbolù bìhem syntaktické analýzy, napøíklad pro atributy tøídy.
		Nároèným úkolem je i práce se jmennými prostory a rùznými modifikátory.\\

		\textbf{Lexikální analýza a sémantická analýza} OOJ nevy¾adují ¾ádné speciální pøístupy nebo nároènìj¹í algoritmy. Je ale nutné zároveò provádìt analýzu sémantickou spolu syntaktickou.\\

		\textbf{Sémantická analýza} stì¾ejní u OOJ, ka¾dý jazyk má jiný pøístup k sémantickým kontrolám a analýzám. Rozdíly jsou hlavnì u staticky a dynamicky typovaných jazycích:
		\begin{itemize}
			\item Kontrola implicitního pøetypování (èasná / statická vazba)
			\item Kontrola explicitního pøetypování objektu -- kontrola typu lze provádìt a¾ pøi samotném bìhu programu, proto¾e pøi pøekladu nejsme schopni s jistotou urèit typ objektu, který se budeme pokou¹et explicitnì pøetypovat
			\item Modifikátory viditelnosti
		\end{itemize}


		\paragraph{Interpret} U interpretace zdrojového kódu OOJ je situace odli¹ná od klasických interpretù ve strukturovaných nebo modulárních jazycích. Vìt¹inou potøebujeme pro práci prostor (workspace), do tohoto prostoru jsou ukládány v¹echny doèasné a potøebné objekty, aby se s nimi dalo pohodlnì manipulovat.

		V interpretech OOJ se uplatòuje pravidlo, ¾e v¹e je objekt, vèetnì pravdivostních i èíselných hodnot. Interpretace probíhá prùbì¾nì, co¾ zpùsobuje rychlou odezvu v pøípadì testování a uèení, Inkrementální programování (Exploratory programming).

		V pøípadì výkonostnì nároèných výpoètu je interpretace nevhodná i pøes mo¾nosti interní optimalizace, která se navenek nesmí projevovat zmìnou chování, ale jedinì vylep¹ením rychlosti èi spotøeby zdrojù.
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Opora 3}
			\subsubsection{Deklarativní jazyky}
			Rozdíl mezi imperativními a deklarativními jazyky je tom, ¾e imperativní krom toho co se má zpracovat je¹tì øe¹í jak se to má zpracovat. \\

			\textbf{Rekurze} v tìchto jazycích nahrazuje cykly. Jedná se o opakování nìjakého výpoètu.

			Mezi deklarativní jazyky øadíme tyto typy:
			\begin{itemize}
				\item (Èistì) funkcionální jazyky
				\item Logické jazyky
				\item Jazyky pro definici a manipulaci s daty \tedy DDL a DML
				\item Nìkteré jazyky s grafickým u¾ivatelským rozhraním
				\item Nìkteré jazyky, èi jejich èásti, pro popis hardware
			\end{itemize}

			\paragraph{Èistì funkcionální jazyky}\footnote{Napø. Haskell} jejich formální báze je $\lambda$-kalkul, na který lze ka¾dý funkcionální jazyk pøelo¾it. \\
			Základní stavebné jednotkou je funkce, v co nejpøesnìj¹ím vyjádøení.
			Mají velkou vyjadøovací schopnost.

			\paragraph{Logické jazyky}\footnote{Napø. Prolog} Formální bází tìchto jazykù je podmno¾ina predikátové logiky, proto¾e v¹echny konstrukce z predikátové logiky nejsou zachyceny. Výpoèetní síla je pøesto stejná jako u ostatních jazykù.\\
			Základní stavební bloky jsou entity jako klauzule, predikáty, termy apod. Na základì vyhodnocovací strategie dochází k vyhodnocení programu -- logické odvození, kdy musejí být splnìna stejná pravidla, jako by se odvození dìlo ruènì na základì pravidel predikátové logiky.	Logické jazyky nejsou urèeny pro poèetní operace.

			\paragraph{Jazyky pro definici a manipulaci dat}\footnote{Napø. SQL, QUEL, QBE} Formální základ mù¾e chybìt, ale mù¾e to být relaèní algebra nebo kalkul nebo jiný tyto jazyky doplòující prvek. \\
			Mají vazbu na pøirozený jazyk (èasto angliètina). Dotaz v tìchto jazycích èasto pasivnì dekódujeme pomìrnì dobøe. \\
			Nejsou výpoèetnì úplné \tedy nelze v nich popsat libovolný algoritmus

			\paragraph{Jazyky s grafickým rozhraním} zdrojový tvar programu je v grafické formì a textová reprezentace se buï nepou¾ívá nebo vùbec neexistuje. Patøí sem jazyky pro popis toku dat nebo signálù. Tyto jazyky nemusejí mít jméno, nebo pøejímají jméno podle vývojového prostøedí.


			\subsubsection{Funkcionální programovací jazyky}
			Paradigma funkcionálních programovacích jazykù: Funkce je základním a jediným výrazovým prostøedkem pro popis a definici algoritmù i dat.\\
			Formální báze je $\lambda$-kalkul, který je v základním pojetí beztypový. Nicménì je mo¾né zavést typovou teorii, v jednoduchém nebo i slo¾itìj¹ím tvaru \tedy promìnné 2. i vy¹¹ích øádù.\\

			\textbf{Typová inference} je automatické typové odvození u jazykù, které typ neuvádìjí.

			Syntaxe je velmi jednoduchá, ve srovnání s imperativními jazyky, nìkdy ale mù¾e trpìt velkým výskytem oddìlovaèù. Sémantika je èasto neformální, s odkazem na formální bázi jazyka. Formalismy a mechanismy, které definují sémantiku:
			\begin{itemize}
				\item Formální systém automatické typové inference
				\item Formální dùkaz toho, ¾e celý jazyk a jeho zpracování a vyhodnocení je vnitønì bezesporné a správné
				\item Denotaèní sémantika
			\end{itemize}
			
			\paragraph{Data a jejich zpracování} Datové typy ve funkcionálních jazycích jsou zastoupeny od jednoduchých a¾ po rekurzivní. To, co chybí, doplní knihovnami nebo abstraktními datovými typy.

			Mezi bázové typy patøí klasické skalární nebo z nich pøímo odvozené. Jsou zastoupené ale i strukturované:
			\begin{itemize}
				\item Seznamy \tedy nad libovolným typem, kvùli silné typovosti homogenní struktura
				\item N-tice \tedy heterogenní datové struktury, nemají explicitní pojmenování
				\item U¾ivatelské typy
				\begin{itemize}
					\item Výètové typy
					\item Záznamy, i pojmenované
					\item Variantní záznamy (jméno u ka¾dé varianty)
					\item Rekurzivní datové typy (mohou kombinovat pøedchozí vlastnosti)
				\end{itemize}
			\end{itemize}

			\textbf{Vstupy a výstupy} jsou ovládány speciálními typy, které jsou zastoupeny v knihovnách, ale èasto implementovány v jiném jazyce.
			Jsou 2 hlavní principy pro realizaci operací:
			\begin{itemize}
				\pojem{Kontinuace}{èasto se pojí s proudovými vstupy a výstupy, idea spoèívá ve vytvoøení dvou funkcí, které pokraèují v závislosti na výsledku vykonání operace}
				\pojem{Monády}{aby bylo zachováno základní paradigma funkce, kdy její výsledek je dán kombinací parametrù, nikoliv historií, akce je potom nìco co nám to zaruèí}
			\end{itemize}

			\textbf{Pole} se díky své imperativní povaze typicky nevyskytují. U ne èistì funkcionálních jazykù se setkáváme s tzv. mutovatelnými polo¾kami, naopak u èistì funkcionálních implementace zcela chybí a nebo se k nim pøistupuje jako k monádùm.\\

			\textbf{Typové promìnné} zastupují konkrétní typ, ten se doplní za promìnnou a¾ podle parametrù v místì aplikace.

			\paragraph{Øídící struktury} Základními strukturami jsou funkce, které se mohou vyskytovat ve zdrojovém textu libovolnì. Rekurzí se dá na funkce odvolávat pouze pokud ji¾ byly definovány. Funkce lze staticky vnoøovat a vytváøet tak lokální funkce, které pomáhají v práci globálnì dosa¾itelným funkcím. Deklarace se spí¹e nevyskytují, nebo vùbec neexistují.

			I ve funkcionálních jazycích se vyu¾ívá modulù, kde je jejich rozhraní odvozeno z nich samých a není tedy nutné explicitnì nìjaké vytváøet.

			Vìtvení programu musí být úplné\footnote{Napø. vìtvení \texttt{if-then-else} musí mít v¾dy èást \texttt{else}} proto, aby pro v¹echny kombinace vstupù bylo mo¾no dospìt k výsledku. 

			\textbf{Návrh programu} Pøi návrhu programu se prakticky nedají uplatnit techniky z imperativního programování:
			\begin{itemize}
				\item Promìnná je pojmenovaná adresa v pamìti
				\item Operace jsou provádìny v poøadí uvedeném ve zdrojovém textu
				\item Je mo¾né vyu¾ít ukazatelù
				\item Známe stav výpoètu a ten manipulujeme
			\end{itemize}
			
			Naopak by návrh programu mìl sledovat strategii vyhodnocení, proto¾e tak lze vytì¾it z jazyka v¹echny jeho výhody, co¾ se projeví na efektivitì zpracování.


			\paragraph{Pøeklad, interpretace} pøeklad je velmi nároèný, pøední èást je velmi zesílená, syntaktická a sémantická analýza probíhá v podstatì nìkolikrát, na rùzných úrovních jazyka. Nejslo¾itìj¹í úlohou pøekladaèe je pøevést deklarativní popis na serializovaný výpoèet realizovaný na von Neumannovské architektuøe dne¹ních poèítaèù.

			Proè mù¾e syntaktická analýza probìhnout nìkolikrát? Postup zpracování funkcionálního jazyka:
			\begin{enumerate}
				\item Expanze syntaktických zkratek
				\item Redukce výrazových schopností jazyka, probíhá v nìkolika krocích \tedy pøevedení výrazovì bohatých konstrukcí na jednodu¹¹í konstrukce, a¾ zbyde malá mno¾ina základních
				\item Automatické odvození typù, typová kontrola
				\item Serializace operací -- závislá na strategii vyhodnocení
				\item Kompletace vìtvení na úrovní rozpoznávání vzorù
				\item Pøevod rozpoznávání vzorù na testování znaèek a kaskádu pøíkazù if-then-else
				\item Závìreèná fáze, pøíprava pro optimalizace a generování kódu
			\end{enumerate}

			\paragraph{Vyhodnocování strategie} jsou podstatné pøi generování kódu, jeliko¾ urèují klíèové vlastnosti jazyka. Ovlivòují tok øízení, pøedávání toku øízení a tvorbu programu. \\
			
			\textbf{Volání hodnotou} \\	Známá strategie z imperativních jazykù, kde jsou parametry vyèísleny pøed voláním funkce, poèet vyhodnocení výrazu je minimálnì jeden, horní mez není urèená.

			Striktní evaluace znamená, ¾e k vyhodnocení dojde právì jednou a hodnoty jsou sdíleny. \\

			\textbf{Volání v pøípadì potøeby} \\ Strategie, kdy dochází k zavolání funkce bez toho, aby se vyhodnotily parametry \tedy jsou pro nì vytvoøeny kontextové obálky. Parametry se tedy vyhodnotí a¾ v pøípadì, kdy ho funkce potøebuje. Poèet vyhodnocení je tedy minimálnì ¾ádný a horní mez opìt není urèena.

			Z této strategie se vyvinula tzv. lazy evaluation, která výrazy vyhodnocuje nejvíce jedenkrát. \\

			\textbf{Dal¹í strategie} jsou významovì nìkde mezi pøedchozími dvìmi. Vyu¾ívají èasto analýzy striktnosti parametrù k tomu, aby dopøedu pøedepsaly strategii vyhodnocení pro jednotlivé pøípady volání funkcí. \\
			

			\textbf{Generování kódu:}
			\begin{itemize}
				\item Pøímá vazba na cílovou platformu -- velmi obtí¾né, nutné dal¹í sni¾ování síly jazyka, úzce spjato s knihovnami pro bìh programu, nìkteré vlastnosti jazyka mohou tak vymizet
				\item Speciální cílový kód urèený pro funkcionální jazyky -- pøeklad je jednoduchý, interpretace takového kódu, pøípadnì jeho semi-interpretace
			\end{itemize}

			\paragraph{Interprety} funkcionálních jazykù v èisté podobì neexistují, v praxi se jedná o pøeklad do specializovaného virtuálního kódu urèeného pro funkcionální jazyky.

			Takový virtuální kód mù¾e být tøeba graf, reprezentace funkcionálních programù takovouto formou je pøirozená a jednoduchá. Zpracování programu je potom redukce takového grafu, ale kvùli rychlosti zpracování se pou¾ívá virtuální kód, který je lineárním zápisem grafu. Dva pøíklady virtuálního kódu:
			\begin{itemize}
				\item Three instruction code
				\item Spineless tag-less G-machine
			\end{itemize}

			\paragraph{Zpracování typù} je ve funkcionálních jazycích zcela speciální kategorie. Jedná-li se o netypovaný jazyk, kontrola se prování a¾ za bìhu, jako u imperativních jazykù. Èasto jsou ale jazyky typované, vyu¾ívá se tedy typového odvození a striktní typové kontroly. \\

			\textbf{Typové tøídy} sou¾í k øe¹ení problému se specializovanými operátory ohlednì rùzných typù operandù. Sdru¾ují funkce a operátory do skupin, kde jsou svázány jistým spoleèným jmenovatelem. \\

			
			\textbf{Formální verifikace} Díky vztahu k $\lambda$-kalkulu je mo¾nost formálnì verifikovat programy na výraznì vy¹¹í úrovni.\\

			\textbf{Mo¾nosti a vhodnosti vyu¾ití} \\
			Nabízejí øadu standardních vlastností, které jsou vhodné pro týmovou spolupráci a tvorbu rozsáhlých programù \tedy modularita, strukturované datové typy, apod.
			

		\subsubsection{Logické programovací jazyky}
			Paradigma logický jazykù: Program v logických programovacích jazycích sestáva z predikátù pøípadnì kombinovaných s omezeními, které pracují nad atomy, termy, èi predikáty.

			Nejznámìj¹í a nejroz¹íøenìj¹í reprezentant je Prolog. Pracuje s predikáty, které mají specifický tvar zvaný Hornovy klauzule.\\

			\textbf{Predikátová logika} je formální báze logických programovacích jazykù. Pøítomnost formální báze je nezbytná u logických jazykù \tedy pùvodní urèení tìchto jazykù bylo automatizovat formální dùkaz v predikátové logice.\\

			\textbf{Jazyk predikátové logiky} se syntakticky skládá z termù, predikátù a formulí. Termy jsou konstanty, promìnné, funkèní symboly.

			\textbf{Term} v predikátové logice je:
			\begin{itemize}
				\item Ka¾dá promìnná
				\item Výraz $f(t_1,\ldots,t_n)$, je-li $f$ n-ární funkèní symbol a $t_1,\ldots,t_n$ jsou termy
				\item Ka¾dý výraz získaný koneèným poètem aplikací pøechozích dvou pravidel, nic jiného term není
			\end{itemize}
			Jeliko¾ jsou termy definovány koneèným poètem pravidel, øíkáme, ¾e to jsou koneèná slova.

			Základní predikáty jsou potom pravda ($T$, \texttt{true}) a nepravda ($F$, \texttt{false}). Formule potom definujeme z predikátù pomocí logických spojek a kvantifikátorù. 

			\textbf{Formule} v predikátové logice je:
			\begin{itemize}
				\item výraz $p(t_1,\ldots,t_n)$, je-li $p$ n-ární predikátový symbol a $t_1,\ldots,t_n$ jsou termy, tento výraz je zván takté¾ atomická formule
				\item výraz: $\neg A$, $(A \land B)$, $(A \lor B)$, $(A \Rightarrow B)$, $(A \Longleftrightarrow B)$, pokud $A$ a $B$ jsou formule
				\item výraz: $\forall x: A, \exists x: A$, pokud $x$ je promìnná a $A$ je formule.	
			\end{itemize}
			
			Sémantika predikátové logiky není dána hned, ale nejdøíve je tøeba definovat interpretaci. Interpretace pøiøazuje význam konstantám, funkcím a predikátùm.\\

			\textbf{Èásteèná rozhodnutelnost} znamená, ¾e nejde v¾dy zcela rozhodnout, zda-li je formule splnitelná èi platná.\\

			\textbf{Splnitelnost} formule je za tìch podmínek, ¾e existuje taková interpretace, která je modelem. Formule je modelem tehdy, kdy¾ je pravdivá pro ka¾dé ohodnocení volných promìnných.\\

			\textbf{Platnost} formule znamená, ¾e je formule pravdivá pøi ka¾dé interpretaci. 

			
			\paragraph{Syntaxe a sémantika} Díky snaze prezentovat jednoduchost syntaxe jazyka se setkáváme i s formálními definicemi. Formálnì se jedná o bezkontextové gramatiky -- zápis termù a predikátù a zejména o notaci pro logické operátory a spojky.

			Sémantika není formálnì prezentována vùbec, neznamená to v¹ak ¾e neexistuje. Velmi èasto se jedná o vysvìtlení na pøíkladech v textu a nebo rovnou, aby si je mohl u¾ivatel vyzkou¹et.


			\paragraph{Data a jejich zpracování} Logické jazyky obsahují klasicky rozsah datových typù od jednoduchých a¾ po slo¾ité slo¾ené struktury. Pomocí knihoven lze tento rozsah roz¹íøit o dal¹í typy.

			Jako prvotní datovou abstrakci mù¾eme brát termy. Lze je pomocí implementaèních trikù konvertovat na predikáty a vyhodnotit. Díky této vlastnosti mohou logické jazyky provádìt sestavování èásti programu a¾ za jeho bìhu. Termy mohou být brány jako pojmenované n-tice, napø:\\ \texttt{osoba('Jan', 'Kadlec', 1969).} \\


			Termy lze vnoøovat, uzavírají se nad atomy. Atomy hrají velkou roli \tedy mohou nést jakoukoliv hodnotu.\\

			\textbf{Seznamy} i literály se zapisují podobnì a práce s nimi je prakticky shodná. V logických jazycích jsou ale seznamy vìt¹inou heterogenní datová struktura.

			Jsou rùzné techniky práce se seznamy, èi termy nebo obecnì daty:
			\begin{itemize}
				\item Rozpoznávání a unifikace vzorù\footnote{Pattern matching} v hlavièce klauzule -- práce s parametry predikátu
				\item Pøevodem na jiný typ -- napø. pøevod mezi termem a sezamem
				\item Pøímý pøístup k termùm
			\end{itemize} 


			\paragraph{Øídící struktury} Základní struktury jsou predikáty/klauzuje, které mají libovolné rozmístìní po zdrojovém textu. Deklarace nejsou povoleny -- nejsou potøeba. Zjednodu¹ený typ deklarace mù¾eme najít pro deklaraci dynamických klauzují, pro deklaraci predikátù exportovaných z modulu. \\


			\textbf{Øízení výpoètu} je dáno cílem výpoètu, kterého chceme dosáhnout, ten pak sestává z dílèích podcílù. Pokud dospìjeme k výsledku, cíl uspìl, podobnì u podcílù. V opaèném pøípadì cíle selhávají.

			
			Vlastní tok øízení/vyhodnocení programu je ovlivnìn výbìrem predikátu/klauzulí na základì unifikace vzorù a na základì uspívání/selhávání tìla dané klauzule. Tìlo klauzuje je specifikováno øadou predikátù. Strategie vyhodnocení rozhodne v jakém poøadí budou predikáty zpracovány, typicky je to zleva doprava. Typ operátoru, pøípadnì podmínìných vyhodnocení\footnote{if-then-else} mù¾e øídit lokální smìr vyhodnocení. \\

			Uva¾ujeme-li Hornovy klauzule, pak zápis v Prologu je tento:
			
			\texttt{a($\ldots$) :- b1($\ldots$), $\ldots$, bm($\ldots$).}
	
			Co¾ znamená, v jazyce predikátové logiky:

			\texttt{$\forall (a(\ldots) \leftarrow b_1(\ldots) \land \ldots \land b_m(\ldots))$}

			Dále mù¾eme upravit:

			\texttt{$\forall (a(\ldots) \lor \neg (b_1(\ldots) \land \ldots \land b_m(\ldots)))$}

			\texttt{$\forall (a(\ldots) \lor \neg b_1(\ldots) \lor \ldots \lor \neg b_m(\ldots))$}

			Výsledný tvar je mo¾né jednodu¹eji programovì vyhodnotit, proto¾e vyhodnocením ka¾dého podcíle ubude z výrazù\footnote{Nepravda nebo výraz \tedy výraz: $\neg T \lor V \rightarrow V$, kde $T$ je pravda a $V$ je výraz} jeden èlen. \\

			\textbf{Backtracking} nastává v pøípadì, ¾e pøi vyhodnocování dojde k selhání. Vrací se ve výpoètu zpìt a hledá jiné mo¾nosti uspìní ji¾ døívì úspì¹ných podcílù. \\


			\textbf{Návrh programu} a implementace mù¾e probíhat jak shora dolù, tak zdola nahoru, nebo kombinací. Díky absenci deklarací je mo¾né kdykoliv a jakkoliv modifikovat program.

			Prolog umí mìnit obsah programu za bìhu, má vestavìné predikáty pro odstranìní i pro pøidání nových.\\

			Logické programovací jazyky jsou jedinou mo¾ností automatizované podpory dùkazù. Nabízejí, oproti jiným jazykùm, zpìtné navracení, které je jinak nutno øe¹it jinak. Vyu¾ívají Garbage Collector pro správu pamìti.

			Neexistuje pro nì, ale èistá kompilace. Rychlost vyhodnocení tak klesá a klesá je¹tì víc s délkou programu. Modularita tìchto jazykù je, a¾ na výjimky, na úrovni zdrojových kódù.

			Tyto negativa spolu s výjimeènými vlastnostmi tyto jazyky odsunuly spí¹e do speciálních oblastí -- simulace, verifikace, apod.

			\paragraph{Pøeklad, interpretace} Pøeklad tìchto jazykù je prakticky nemo¾ný z dùvodu mo¾nosti modifikace programu za bìhu, tudí¾ bìhem pøekladu neznáme pøesný poèet klauzulí apod. Pokud je ale pøeklad uskuteènitelný, výsledkem je kód, kdy jeho èásti jsou pøímo vyhodnocovány, ale souèástí je také plný interpret, který èásti interpretuje a pøípadnì supluje vyhodnocovací strategii pro klauzule utvoøené za bìhu programu.

			Pøeklad se vìt¹inou dìje do vy¹¹ích programovacích jazykù nebo do speciálního mezikódu, pøímo reflektující stavbu klauzulí, který je potom interpretován.\footnote{Napøíklad jazyk G\"odel byl pøekládán do Prologu}\\

			Interpretace je mnohem èastìj¹í, pøímá interpretace není mo¾ná. Dochází k transformaci do interní podoby (stromová struktura) a ulo¾ení do databáze (u¾itím rozptylovaících funkcí -- hash function). Databáze má praktické limity jak pro celkový obsah, tak pro efektivní vyhodnocení.

			Interpret potom pracuje nad takovou interní reprezentací a pøistupuje pøímo do databáze. Opìt platí vyu¾ití Garbage Collectoru a zpìtného navracení. Zpùsob vnitøního ulo¾ení je optimalizován pro zrychlení vyhodnocení.


			\paragraph{SLD rezoluce} je vyhodnocovací strategie pro jazyk Prolog. Vstupem jsou Hornovy klauzule. Vyhodnocení probíhá:
			\begin{enumerate}
				\item Klauzule jsou z databáze vybírány shora dolù, dle umístìní ve vstupním textu.
				\item Tìla predikátù jsou zpracovávána zleva doprava
			\end{enumerate}
			
			Jedná se tedy o prohledávání do hloubky -- dokud neuspìje první podcíl, ostatní zùstávají nedotèené.

			Pøíklad:
			\begin{quote}
			\begin{verbatim}
			1: a(...) :- b(...), c(...), d(...).
			2: a(...) :- d(...), e(...).

			3: b(...) :- c(...), d(...), c(...).
			4: b(...) :- e(...).

			5: c(...) :- d(...).
			6: c(...) :- e(...), d(...), c(...).

			7: d(...).
			8: d(...) :- e(...), d(...).

			9: e(...).
			\end{verbatim}
			\end{quote}
			Øe¹ení:
			Chceme vyhodnotit predikát a, vyhodnocení tedy zaène bodem 1.

			\texttt{a(...) -->> b(...), c(...), d(...).}

			Dále je nutné vyhodnocení prvního podcíle b(...).

			\texttt{b(...) -->> c(...), d(...), c(...).}

			Stejný nech» je postup s podcílem c, tedy:

			\texttt{c(...) -->> d(...).}

			Tady se dostáváme do stavu, kdy je potøeba ovìøit klauzuli d, která je ale bez tìla (øíká se jí fakt). Která ale sel¾e:

			\texttt{d(...).}

			Musíme tedy uplatnit druhou klauzuli predíkátu d, tedy:

			\texttt{d(...) -->> e(...), d(...).}

			Prùbìhem tohoto postupu dochází k unifikaci mezi promìnnými a hodnotami, které se objevují na pøíslu¹ných pozicích parametrù. Pokud dojde k uspìní cíle, tak kromì oznámení úspìchu je vypsána substituce pro nejvy¹¹í úroveò promìnných.\\

			\textbf{Unifikace} je v logických jazycích velmi dùle¾itý postup. Probíhá pøi hledání hlavièky podcíle v databázi klauzulí, kdy klauzule oèekává parametry jistého tvaru nebo je pøijímá, pøípadnì v dobì explicitního vynucení unifikace, kdy jsou proti sobì postaveny termy/promìnné.

			Dochází tak k vzájemnému provázání mezi promìnnými a dal¹ími entitami v celém programu. Unifikace probíhá v¾dy na úrovni termù a hledá se nejobecnìj¹í unifikátor\footnote{Most general unifier, MGU}.\\

			\textbf{Nejobecnìj¹í unifikátor} je takový, ¾e neexistuje ¾ádný jiný unifikátor, který by pro nìjakou èást unifikace nabízel obecnìj¹í øe¹ení, pøitom dva unifikátory jsou nejobecnìj¹í, pokud se li¹í pouze pøejmenováním volných promìnných.\\

			Typické vlastnosti unifikace v logických jazycích:
			\begin{itemize}
				\pojem{Kontrola výskytu}{ovìøuje se, zda proti sobì stojí dvì identické promìnné, nebo» to mù¾e v øadì pøípadù vést k nekoneèným termùm, apod.}
				\pojem{Hloubka unifikace}{unifikace neprobíhá na libovolnì rozsáhlých termech}
				\pojem{Zpracování cyklických a nekoneèných struktur}{èasto zakázáno a úzce souvisí s kontrolou výskytu}
			\end{itemize}

			\textbf{Robinsonùv algoritmus} \label{teor:robinson}
			\begin{quote}
			\begin{alltt}
			Vstup: \(\Delta\), mno¾ina literálù
			Výstup: \(\mu\), mgu nebo selhání/neúspìch

			\(\mu\) = []                                              (prázdná substituce)
			dokud v \(\mu\)(\(\Delta\)) existuje nesouhlasný pár
			    najdi první nesouhlasný pár \(p\) v \(\mu\)(\(\Delta\))
			    pokud v \(p\) není ¾ádný volná promìnná
			        skonèi selháním unifikace
			    jinak
			        nech» \(p\) = (\(x\),\(t\)), kde \(x\) je promìnná
			        pokud se \(x\) vyskytuje v \(t\)                    (kontrola výskytu)
			            skonèi selháním unifikace
			        jinak
			            nastav \(\mu\) = \(\mu\) \(\circ\) [\(t\)/\(x\)]
			vra» \(\mu\)
			\end{alltt}
			\end{quote}

			\textbf{Zpracování typù} se provádí a¾ ve chvíli kdy to nìjaká operace vy¾aduje. Poèet základních typù je nízký a jen ojedinìle je mù¾e programátor obohatit o svoje. Síla termù a struktur je v tomto pøípadì dostaèující. \\

			\textbf{Formální verifikace} programù v logických jazycích neprovádíme, jedná se o formule v predikátové logice, tudí¾ jsme omezeni samotnou predikátovou logikou. U strukturálních algoritmù je mo¾né pou¾ít strukturální indukci.

			\paragraph{Mo¾nosti a vhodnosti vyu¾ití} Pro vìt¹í projekty se tyto jazyky mohou hodit, ale nemusí. Pomìrnì rozsáhlé programy mohou být vytvoøeny jedním programátorem.

			Pøi tvorbì programu je potøeba pøemý¹let, jakým zpùsobem se vybírá klauzule pro dal¹í vyhodnocení, stejnì tak to, ¾e systém má vestavìnou strategii zpìtného navracení.

			Je potøeba si dávat pozor na efektivitu a optimálnost programu, proto¾e vyhodnocovací mechanismus uplatòuje slepou strategii výpoètu, kterou øídí program, ¾ádné zefektivnìní není.



		\subsubsection{Ostatní deklarativní jazyky}
			\paragraph{Jazyky pro definici a manipulaci dat} se rozdìlují do dvou druhù:
			\begin{itemize}
				\item DDL -- Data Definition Language
				\item DML -- Data Manipulation Language
			\end{itemize}

			Mají ni¾¹í vyjadøovací sílu ne¾ Turingovy stroje (není mo¾né jimi popsat libovolný algoritmus). I kdy¾ existuje formální základ jejich syntaxe, tak jsou èasto blízké pøirozeným jazykùm, resp. angliètinì. Je tedy snadné pøeèíst a pochopit co popisují.

			Vytváøené akce typicky nemají pojmenování a není mo¾né se tedy na nì odvolávat a takto strukturovat. Èasto se to obchází integrací do skriptovacího jazyka, který to umo¾òuje.

			Èasto jazyky obsahují velké mno¾ství klíèových slov, funkcí èi operátorù. Rùzné databázové systémy jsou rùznì roz¹iøovány a upravovány, aby poskytly vlastnosti vycházející z implementace SØBD a nabídly tak nìjakou výhodu oproti ostatním implementacím.

			Existuje gramatika, která rozhoduje u zpracování tìchto jazykù. Syntaktická analýza se pak dá zpracovat bì¾nými prostøedky. Sémantická analýza je závislá na okam¾itém stavu SØBD, pokud se jedná o dotaz, který ète z báze dat, tak výsledkem sémantické analýzy a pøípravy vykonání dotazu je i postup v jakém se jednotlivé kroky mají vykonat.

			Po¾adavky jsou vyhodnocovány okam¾itì s tím, ¾e po¾adavek je interpretován, po kompletní analýze a pøevodu na postup vykonání základních operací. \\

			\textbf{Distribuované databáze} vy¾adují perfektní pøípravu dotazu, nebo» pøesun velkého mno¾ství dat po síti by byl pochopitelnì né¾adoucí, zvlá¹tì pokud by to bylo zbyteèné.

			Kromì klasických optimalizaèních postupù se nasazují postupy pro paralelní vyhodnocení.\\

			\textbf{Databáze pro speciální typ dat} jsou napøíklad prostorové, temporální, multimediální, které disponují vestavìnými operacemi pro manipulaci se specifickým typem dat. \\


			\paragraph{Jazyky s grafickým rozhraním} pøedstavují diagramy datových èi signálových tokù:
			\begin{itemize}
				\item DFD -- Data Flow Diagram
				\item SFD -- Signal Flow Diagram
			\end{itemize}

			Nìkdy jde do tého tøídy zaøadit i stavové diagramy, èi koneèné automaty.

			Tvorba programu v tìchto systémech se hodnì podobá kreslení v programu pro vektorovou grafiku (CAD systémy, apod.). Èasto jsou manipulovány i podobné objekty, dají se otáèet, propojovat, apod.

			Program mù¾e být ulo¾en v textové formì (napø. XML), ale není to vhodné pro pøímý zápis.

			Pro odladìní programù je typickou souèástí vývojového prostøedí simulátor. Cílová platforma je èasto odli¹ná od té na které je program vyvíjen.

			Analýza takovýchto jazykù probíhá bìhem tvorby diagramu. Pøed simulací, èi generováním cílového kódu v¹ak probìhne kompletní analýza, která zkontroluje korektnosti diagramu. \\



			\paragraph{Srovnání deklarativních jazykù} Je mo¾né vypozorovat nìkteré spoleèné a typické vlastnosti, které nalezneme u v¹ech, jsou to zejména:
			\begin{itemize}
				\item Pøed vyhodnocením, èi generováním kódu dochází k serializaci kódu, která je øe¹ena kompilátorem, èi interpretem
				\item Pokud je porovnáváme s jazyky imperativními, tak nám v¾dy nabízejí ''nìco navíc''
				\item Úroveò abstrakce je èasto mnohem vy¹¹í (hardware je èasto úplnì schován a není mo¾né na nìj nijak pøistoupit)
				\item Naprostá vìt¹ina tìchto jazykù má jasnou a èasto i pøímou vazbu na nìjakou formální bázi na které je postavena
			\end{itemize}

			\noindent Mezi jednotlivými typy deklarativních jazykù v¹ak mù¾eme najít i øadu odli¹nosti:
			\begin{itemize}
				\item Slo¾itost analýzy je rùzná (Prolog vs. Haskell vs. SQL)
				\item Práce s typy a jejich zpracování je rùzné (Prolog vs. Haskell)
				\item Implicitní mo¾nosti paralelizace èi serializace se rùzní (Prolog vs. SQL)
				\item Výpoèetní síla (SQL vs. Haskell)
				\item Úroveò deklarativy (Haskell vs. Prolog)
				\item Typická aplikaèní doména
			\end{itemize}
		
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\newpage
	\section{Otázky}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{SLD rezoluce} \hfill (5x)
		\begin{itemize}
			\item Vyhodnocovací strategie pro Prolog a dal¹í jazyky
			\item Vstupem jsou Hornovy klauzule
			\item Vyhodnocení:
			\begin{itemize}
				\item Klauzuje jsou z databáze vybírané shora dolù, podle umístìní ve vstupním textu
				\item Tìla predikátù jsou zpracované zleva doprava
			\end{itemize}
			\item Jedná se o prohledávání do hloubky -- dokud neuspìje první podcíl, ostatní zùstávají nedotèené
			\pojem{Unifikace}{Probíhá v dobì hledání hlavièky podcíle v DB klauzulí, klauzule oèekává parametry urèitého tvaru nebo je pøijímá}
			\item Probíhá v¾dy na úrovni termù a hledá nejobecnìj¹í unifikátor
			\pojem{Nejobecnìj¹í unifikátor}{Reprezentuje nejobecnìj¹í øe¹ení dané unifikace}
			\item Vlastnosti unifikace:
			\begin{itemize}
				\pojem{Kontrola výskytu}{Ovìøuje se, zda proti sobì stojí dvì identické promìnné, nebo» to mù¾e v øadì pøípadù vést k nekoneèným termùm}
				\pojem{Hloubka unifikace}{unifikace neprobíhá na libovolnì rozsáhlých termech}
				\pojem{Zpracování cyklických a nekoneèných struktur}{èasto zakázáno a úzce souvisí s kontrolou výskytu}
			\end{itemize}
		\end{itemize}
		


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Doba ¾ivota promìnné} \hfill (1x)
	\begin{itemize}
		\item Èasový interval, po který je pro danou promìnnou pøidìlená pamì»
		\item Pøidìlení probíhá staticky nebo dynamicky
		\item Dynamické pøidìlování je buï automatické nebo explicitní nìjakým pøíkazem
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Pøekladaè} \hfill (5x)
	\begin{itemize}
		\item Program, který vstupní text programu pøevádí na posloupnost pøíkazù jiného jazyka, èi stroje.
		\item Cílem takového pøekladu mù¾e být napø. binární soubor, který je pøímo spustitelný na dané architektuøe (cílovým jazykem pøekladu jsou instrukce procesoru dané platformy).
	\end{itemize}
		\subsubsection*{Nestrukturované jazyky}
		\begin{itemize}
			\item Text programu pøevádí na soubor spustitelný v dané architektuøe
		\end{itemize}
		\subsubsection*{Strukturované jazyky}
		\begin{itemize}
			\item Fáze pøekladu
			\begin{itemize}
				\pojem{Lexikální analýza}{více kategorií lexémù}
				\pojem{Syntaktická analýza}{prediktivní analýza, analýza zdola nahoru}
				\pojem{Sémantická analýza}{Víceúrovòové tabulky symbolù}
			\end{itemize}
		\end{itemize}
		\subsubsection*{Modulární jazyky}
		\begin{itemize}
			\item Fáze pøekladu
			\begin{itemize}
				\pojem{Lexikální analýza}{textový preprocesor}
				\pojem{Syntaktická analýza}{metody pro bezkontextové gramatiky}
				\item \textbf{Sémantická analýza}
				\pojem{Linker}{spojuje a vzájemnì provazuje symboly, výstupem je spustitelný kód}
			\end{itemize}
		\end{itemize}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Linker} \hfill (5x)
	\begin{itemize}
		\item Spojuje v¹echny moduly a èásti knihoven do jednoho spustitelného souboru
		\item Pricipiálnì dvouprùchodový \tedy zkompletovat informace a pak dosazení odkazù
		\item V modulárních jazycích
		\item Nové typy chyb:
		\begin{itemize}
			\pojem{Chybìjící symbol}{Nìkterý z modulù po¾aduje symbol, který ¾ádný jiný modul nedefinuje}
			\pojem{Vícenásobná definice}{Nìkterý ze symbolù je definován a exportován více moduly}
			\pojem{Rozdílné typy symbolù}{Konflikt mezi typem symbolu, který je vyvá¾en jedním a dová¾en jiným modulem}
		\end{itemize}
		\item Vstup linkeru \tedy relativní kód, výstup pøekladu, vazby na promìnné pøes tabulku urèující o jaký symbol se jedná
		\pojem{Úloha linkeru}{spojuje a vzájemnì provazuje symboly, které nìkdo po¾aduje, se symboly, které jiný modul vyvá¾í}
		\item Výsledkem práce je relokatibilní kód (exe) nebo absolutní kód (vestavìné systémy, ...)
		\pojem{Absolutní kód}{kromì propojení symbolù musí urèit adresy v¹ech entit programu a zmodifikovat kód, který na nì odkazuje. Problémy: segmentace, pøístupové metody, velikost pamìti, promìnná délka instrukcí}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Catch blok} \hfill (3x)
	\begin{itemize}
		\item \emph{Jaký druh parametru se nacházi v bloku catch pøi vyvolání vyjímky}
		\item Formální parametr je typu výjimky (tøída v OOJ) a tedy parametr bývá objekt vyvolané výjimky
		\item Výjimka jako taková je tedy promìnná \tedy hodnota, ne druh
		\item Situace v bloku catch:
		\begin{itemize}
			\item[a.] Objekt výjimky je instancí tøídy nebo libovolné její podtøídy, která je deklarována jako typ parametru bloku catch
			\item[b.] Objekt výjimky se v bloku nezachytí, tak¾e se hledá dal¹í mo¾ný catch blok. Pokud ale není nalezen výjimku zpracuje systém nebo virtuální stroj
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Pøedávání parametrù} \hfill (3x)
	\begin{itemize}
		\item \emph{Pøedávání parametrù u strukturovaných imperativních jazykù}
		\item \textbf{HELP!!!!! u strukturovaných imperativních není nikde popis} 
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{ADL} \hfill (4x)
	\begin{itemize}
		\item Jazyk pro popis architektury procesoru
		\pojem{Nevýhody HDL}{odstraòují jazyky pro popis architektury procesoru (ADL) -- automatické generování nástrojù pro vývoj mikroprocesoru}
		\item Kategorie ADL
		\begin{enumerate}
			\item \textbf{Jazyky zamìøené na instrukèní sadu}
			\begin{itemize}
				\pojem{nML}{Formalismus pro popis instrukèní sady}
				\begin{itemize}
					\item Èásti jazyka nML \tedy popis instrukèní sady, struktury, èasování, chování
					\item Dovoluje struèný hierarchický popis mikroprocesoru v behaviorálním stylu
					\item Instrukce je popsána jednou nebo více operacemi
					\item Instrukèní sada je popsána pomocí atributované gramatiky
					\pojem{Atribut image}{binární reprezentace operace}
					\pojem{Atribut syntax}{assemblerovský zápis operace}
					\item Úlo¾i¹tì jsou zde rozdìlena na: RAM, registr a tranzistorové úlo¾i¹tì
				\end{itemize}

				\pojem{Sim-nML}{Modelování øídících tokù a závislostí mezi instrukcemi}
				\begin{itemize}
					\item Modelování linek zøetìzení, predikce skokù, hierarchických pamìtí
					\pojem{Nevýhody}{generovaný simulátor je pomalý, nemo¾nost namodelovat nìkterá roz¹íøení procesoru}
				\end{itemize}

				\pojem{IDSL}{Instruction-Set Description Language}
				\begin{itemize}
					\item Primárnì popis instrukèní sady procesorù VLIW
					\item Jazyk je podobný nML, je roz¹íøen o definici omezení, platné instrukce pøi konfliktech
					\item Neumo¾òuje popis zøetìzení 
				\end{itemize}
			\end{itemize}
			
			\item \textbf{Jazyky zamìøené na strukturu}
			\begin{itemize}
				\item Zamìøující se na strukturální komponenty a propojení architektury procesoru
				\item Ni¾¹í úroveò abstrakce
				\pojem{Nevýhody}{u strukturálních jazykù je pomalost generovaných simulátorù}
				\pojem{MIMOLA}{popisný hardwarový jazyk a vy¹¹í programovací}
				\begin{itemize}
					\pojem{Výhoda}{jediný popis mù¾e být pou¾it pro syntézu HW, simulaci a pro úèely generování kódu}
					\pojem{Nevýhoda}{nízké abstrakce \tedy pomalý simulátor}
					\item Obsahuje 2 èásti
					\begin{itemize}
						\item[$\circ$] Hardwarová èást \tedy specifikuje mikroarchitekturu ve formì netlistu komponent
						\item[$\circ$] Softwarová èást \tedy popisuje aplikaèní v syntaxi podobné PASCAlu
					\end{itemize}
				\end{itemize}

				\pojem{Coach}{vyvinut pro návrh ASIP}
				\begin{itemize}
					\item Zalo¾en na jazyku UDL/I -- popis procesoru na úrovni meziregistrových pøenosù, popis je zalo¾en na jednotlivých cyklech procesoru
					\pojem{Výhoda}{popis v UDL/I je plnì syntetizovaný}
					\pojem{Nevýhoda}{malá rychlost symulátoru, chybí podpora superskalárních a VLIW mikroprocesorù}
				\end{itemize}
			\end{itemize}

			\item \textbf{Jazyky pro popis instrukèní sady a struktury}
			\begin{itemize}
				\pojem{RADL}{roz¹íøení døívìj¹í práce na jazyce LISA}
				\begin{itemize}
					\item zamìøuje se na explicitní podporu detailního chování zøetìzení
					\item zamìøuje se na pøenositelné simulátory
				\end{itemize}

				\pojem{AISA}{poskytuje metody pro odvození nejlep¹í kombinace instrukèní sady a mikroarchitektury z dané mno¾iny testù aplikace}
				\begin{itemize}
					\item Pracuje s instrukèní sadou a mikroarchitekturním zøetìzením
					\item Systém zahrnuje mno¾inu srovnávacích mìøítek aplikace, úèelové funkce a model zøetìzení
				\end{itemize}
			\end{itemize}
		\end{enumerate}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{LISA} \hfill (4x)
	\begin{itemize}
		\item Smí¹ená kategorie ADL
		\item Jazyk pro popis instrukèní sady a struktury
		\item Umo¾òuje plnì automaticky generovat v¹echny nástroje pro programování a simulaci ASIP
		\item Model obsahuje:
		\begin{itemize}
			\item \textbf{Deklarace zdrojových prvkù}
			\begin{itemize}
				\item Deklarované zdrojové prvky udr¾ují stav programovatelné architektury ve formì ulo¾ené datové hodnoty
				\item Sekce zdrojù definuje v¹echny zdroje modelu LISA
				\item Linky zøetìzení:
				\begin{itemize}
					\item[$\circ$] Zlep¹ení prùchodu instrukcí procesorem
					\item[$\circ$] Zøetìzené zpracování (pipeline) si musí pamatovat stavy instrukcí v rùzném stavu rozpoznávání
					\item[$\circ$] Zøetìzené zpracování sestává ze 4 stavù
				\end{itemize}
				\item Pamìti:
				\begin{itemize}
					\item[$\circ$] umo¾òuje popisovat ideální pamìti i neideální komponenty
				\end{itemize}
				\item Pøístup do pamìti:
				\begin{enumerate}
					\pojem{Èistì funkcionální}{pamì» je modelována jako èisté pole C a pøistupuje se k ní operátorem[], data jsou vracena bezprostøednì a není shroma¾ïována ¾ádná statistika}
					\pojem{Pøesné poèítání cyklù}{pøístup pro sbìrnice, RAM a cache. }
					\pojem{Zalo¾eno na cyklech}{Nejpøesnìj¹í modelovací metoda. Podává zprávu o omezeném poètu pamì»ových/sbìrnicových portù, pøístup do pamìti z rùzných fází linky zøetìzení}
				\end{enumerate}
				\item Mapování pamìti:
				\begin{enumerate}
					\item Pro spu¹tìní simulátoru je nezbytné zobrazení adresovaného prostoru procesoru nad definovanými pamì»mi
					\item Zobrazení musí být jednoznaèné
					\item Existuje jedno nebo více mapování pamìti
				\end{enumerate}
			\end{itemize}
			\item \textbf{Popis operací hardwaru}
			\begin{itemize}
				\item Operace je základní objekt v jazyku LISA
				\item Obsahuje kolekci popisù rùzných vlastností systému
				\item Operace mohou být buï atomické, nebo se instrukce skládají z jiných operací
				\item Operace:
				\begin{itemize}
					\pojem{DECLARE}{lokální deklarace platné v rámci v¹ech sekcí aktuální operace}
					\pojem{INSTANCE}{odkazy na jiné operace}
					\pojem{GROUP}{sdru¾ují operace, které mohou být u¾ity ve stejném kontextu}
					\pojem{LABEL}{umo¾òuje pojmenovávat úseky textu na assemblerovské úrovni}
					\pojem{CODING}{Popisuje binární obraz instrukèního slova}
					\pojem{SYNTAX}{Textová reprezentace instrukcí na assemblerovské úrovni}
					\item atd.
				\end{itemize}
			\end{itemize}
		\end{itemize}
	\end{itemize}

	 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
	\subsection{Návrhové vzory} \hfill (7x)
	\begin{itemize}
		\item Obecná znovupou¾itelná øe¹ení èasto se vyskytujících problémù v programovém návrhu.
		\item Jedná se o popis postupu nebo ¹ablonu, pomocí které pohodlnì daný problém správnì a efektivnì vyøe¹íme
		\item Systematicky nazývají, vysvìtlují a vyhodnocují dùle¾itý a v objektovì orientovaných systémech opakující se návrh
		\item Objektovì orientované návrhové vzory se typicky týkají vztahù a interakcí mezi tøídami a objekty, ani¾ bychom pøímo specifikovali konkrétní tøídy a objekty na¹í konkrétní aplikace.
		\item Umo¾òuje efektivní sdílení návrhových my¹lenek, znovupou¾ití znalostí a zku¹eností
		\item Jazyk návrhových vzorù je mno¾ina návrhových vzorù
		\item Návrhové vzory vs Frameworky -- Frameworky umo¾òují ménì svobody, NV jsou více abstraktní a ménì specifické. Pøi pou¾ití FW se vzdáváme svobody pøi návrhu programu.
		\pojem{Výhody}{Vìt¹í flexibilita a znovupou¾itelnost návrhu}
		\pojem{Nevýhody}{Pomalej¹í kód (pøípadnì nepochopení problematicky návrhových vzorù, kdy¾ nejsou v kódu oznaèeny a vysvìtleny)}
		\item Má uniformní strukturu a skládá se:
		\begin{itemize}
			\pojem{Jméno}{návrhového vzoru}
			\pojem{Popisu problému}{podrobný popis jaký problém øe¹í}
			\pojem{Popisu øe¹ení}{zpùsob jakým lze vzor implementovat}
			\pojem{Dùsledky pou¾ití}{co zpùsobí pou¾ití vzoru(výhody a nevýhody)}
		\end{itemize}
		\item Flexibilita:
		\begin{enumerate}
			\pojem{Tøídnì orientované}{Vyu¾ívají zejména tøídní dìdiènost}
			\pojem{Objektovì orientované}{Vyu¾ívají zejména kompozici objektu a umo¾òují vy¹¹í flexibilitu}
		\end{enumerate}
		\item Úèel:
		\begin{enumerate}
			\pojem{Vytváøecí vzory}{nepøímou cestou pro nás vytváøí objekty, ani¾ bychom je museli vytváøet pøímo, a poskytují nám tak vìt¹í flexibilitu programù (Abstraktní továrna, Jedináèek, Tovární metoda)}
			\pojem{Strukturální vzory}{napomáhají pøi shlukování objektù do vìt¹ích celkù, jako napøíklad komplexní u¾ivatelské rozhraní apod. (napø. Adaptér, Dekorátor, Kontejner, Proxy, Skladba)}
			\pojem{Vzory chování}{pomáhají pøi definici komunikace mezi objekty v systému a toku øízení ve slo¾itìj¹ích programech (Pozorovatel, Náv¹tìvník, Observer, Strategie, ©ablonová metoda)}
		\end{enumerate}
		\item Vzory:
		\begin{itemize}
			\pojem{Abstraktní továrna}{máme nìkolik sad objektù s podobnou funkèností a chceme v¾dy vybrat jednu sadu a tu pou¾ívat bìhem celého bìhu a mít mo¾nost rychle a efektivnì mìnit pou¾ívanou sadu, ani¾ bychom mìnili samotný kód (pø. Sada grafických prvkù urèitého okenního systému, ka¾dý systém má své)}
			\pojem{Adaptér}{potøebujeme-li, aby spolupracovaly dvì tøídy s nekompatibilním rozhraním. Konvertuje rozhraní, aby bylo kompatibilní k pou¾ití s druhou tøídou. (pøi vytváøení podtøíd)}
			\pojem{Dekorátor}{Dynamické pøidìlování nových vlastností a funkènosti objektu za bìhu.Pøíklad: V kavárnì máme spoustu mo¾ností, co pøidat do kafe jako cukr, mlíko atd. (dekorátory) a chceme vypoèítat výslednou cenu. Nechceme ale, aby ve tøídì kafe byly ceny mlíka atd. a nechceme modifikovat tøídu kafe kvùli nové mo¾nosti, tøeba zmrzlinì. Vezmeme tedy konkrétní komponentu (kafe nebo èaj), pøidáme dekorátor (zmrzlina) a máme výsledný objekt. Dekorátory mù¾eme obalovat dal¹ími dekorátory, ale ne komponentami}
			\pojem{Jedináèek(singleton)}{umo¾òuje vytváøet z tøídy maximálnì jednu instanci. Typicky kdy¾ pøistupuji k nìjakému zdroji (filesystem, tiskárna, sí»ové rozhraní), kdy vy¾adujeme výluèný pøístup. K roz¹íøení chování mù¾eme vyu¾ít dìdiènost. Doba instanciace: Bìhem startu programu/Za bìhu programu}
			\pojem{Observer}{umo¾òuje ¹íøení události, která nastala v jednom objektu, ke v¹em závislým objektùm}
			\pojem{Skladba}{pomáhá skládat objekty do stromových hierarchií(není tam cyklus, jednotné rozhraní pro pøístup k uzlùm a listùm) Tam kde objekty vytvaøí hierarchii, kde dohromady tvoøí celek, a kde i celky mohou být podcelky jiných vy¹¹ích celkù.}
			\pojem{Strategie}{zapouzdøuje algoritmy (objekty) a umo¾òuje jejich zamìnitelnost. Umo¾òuje zmìnu algoritmu nezávisle na klientovi, který ho vyu¾ívá}
			\pojem{©ablonová metoda}{definuje kostru, jak nìjaký algoritmus funguje, s tím, ¾e nìkteré kroky nechává na potomcích \tedy umo¾òuje tak potomkùm upravit urèité kroky algoritmu bez toho, aby mohli mìnit strukturu algoritmu.}
			\pojem{Tovární metoda}{pozdr¾í rozhodnutí dokud nevíme jakou tøídu bude potøeba instanciovat (jakou pizzu si zákazník objedná, tak takovou udìláme)}
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Syntaxe} \hfill (1x)
	\begin{itemize}
		\item Definuje strukturu programu. tj. jakým zpùsobem je dovoleno jednotlivé konstrukce øadit za sebe
		\item èasto vysvìtluje i lexikální stavba jazyka
		\item Pro definici syntaxe pro úèely popisu jazyka pro progamátory se v souèasnosti pou¾ívá buïto slovní popis (zøídkavì), syntaktické grafy, BNF, èi EBNF, nebo gramatiky
		\item Dle jazykù:
		\begin{itemize}
			\pojem{Nestruktoravané}{popsána pøirozeným jazykem a pøíklady ukazujícími správný zápis}
			\pojem{Strukturované}{podávána formální, èi semiformální formou z dùvodù:}
			\begin{itemize}
					\item Ukázat logiku a hierarchii jazykových konstrukcí
					\item Pøehlednost a pøevzetí základních formalismù i do ¹ir¹í obce u¾ivatelù
			\end{itemize}
			\item Popis syntaxe:
			\begin{itemize}
					\item (E)BNF (roz¹íøená Backus-Naurova forma)
					\item Syntaktické grafy
					\item Gramatiky
			\end{itemize}
			\pojem{Modulární}{podávaná formální nebo semiformální cestou, popsaná (E)BNF -- Roz¹íøenou Backus-Naurovou formou, syntaktickými grafy, formálními gramatikami (bezkontextové)}
		\end{itemize}
		\item Syntaktická analýza:
		\begin{itemize}
			\pojem{Nestruktorovaný pøekladaè}{typicky  bezkontextové  vlastnosti  (kontrola závorek), mo¾nost  vyu¾ít formální aparáty}
			\pojem{Nestruktorovaný interpret}{øádkovì orientovaná u nových jazykù je závislost pøíkazù na øádek eliminovaná. Èasto lze uplatnit intuitivní postupy a urèité operace se provádìjí ji¾ pøi vkládání textu. Text nebývá pøedzpracován ale je neustále znovu plnì analyzován nebo pomocí metody pøekladu v dobì vyhodnocení/bìhu pøelo¾en do instrukcí cílové architektury -- \textbf{just in time compilation, JIT}}

			\pojem{Struktorovaný pøekladaè}{vyu¾ívá techniky pro analýzu bezkontextových jazykù (metoda shora dolù nebo zdola nahoru)}

			\pojem{Modularní pøekladaè}{zalo¾ena na bezkontextových gramatikách, novým prvkem je oznaèování symbolù vyvá¾ených z modulu a dová¾ených do modulu}
			\item \textbf{Modulární interpret}
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
	\subsection{Sémantika} \hfill (1x)
	\begin{itemize}
		\pojem{Popis/definice}{významu jednotlivých syntaktických konstrukcí, zpùsobu jejich vyhodnocení, zpracování, atd.}
		\item Formální popis:
		\begin{itemize}
			\pojem{Axiomatickou sémantiku}{pro ka¾dou syntaktickou konstrukci definuje mno¾inu axiomù, které musí být splnìny, aby byla konstrukce platná}
			\pojem{Operaèní sémantiku}{definuje sémantiku chování programu jako posloupnost pøechodù mezi danými stavy}
			\pojem{Denotaèní sémantiku}{Program je definován jako matematická funkce, která zobrazuje vstupy navýstupy}
		\end{itemize}
		\item Dle povahy:
		\begin{itemize}
			\pojem{Statická sémantika}{popisuje vlastnosti, které mohou být studovány a ovìøovány v dobì  analýzy/pøekladu  programu, napø. typová kompatibilita, existence promìnných}
			\pojem{Dynamická sémantika}{popisuje vlastnosti, jejich¾ splnìní lze ovìøit a¾ v dobì bìhu programu, napø. velikost indexu pole daného výrazem, velikost výsledku, apod }
		\end{itemize}
		\item Dle jazykù:
		\begin{itemize}
			\pojem{Nestruktoravané}{podávána neformálnì. Typicky pøíklady doplnìné popisem, který vysvìtluje dané chování. Èastý je inkrementální popis (od jednoduchých po slo¾ité)}
			\pojem{Strukturované}{vedena neformální cestou, ale velmi propracovaná a standardizovaná. Vysvìtlena obecnì a pøíklady uvedeny pouze na dokreslení. Velmi rozsáhlá}
			\pojem{Modulární}{podávaná neformálnì (kromì tìch jazykù, které mají formální bázi), vznikají standardy (ANSI C), obsahují i pøíklady }
		\end{itemize}
		\item Sémantická analýza:
		\begin{itemize}
			\pojem{Nestruktorovaný pøekladaè}{v dobì pøekladu lze bezpeènì kontrolovat pouze existenci cíle skokù, nic jiného, zbytek za bìhu programu. U¾ití jednoúrovòové tabulky symbolù pro analýzu kontextu -- na konci analýzy/pøekladu známe poèet u¾itých symbolù, min. velikost pamìti pro ulo¾ení v¹ech hodnot}
			\pojem{Nestruktorovaný interpret}{provádìná v jisté postupnosti (jen èást kontrol), nebo je mo¾né ji odlo¾it a¾ na samotné vyhodnocení \tedy jistý prvek nestability \tedy dopøedné skoky, kde je nutné pøeskoèit èást textu (nejde bez analýzy) a najít cíl skoku (mù¾e být limitovaná délka textu mezi poèátkem a ukonèení konstrukce, zde skoku). Jednoúrovòové tabulky symbolù pro analýzu kontext}

			\pojem{Struktorovaný pøekladaè}{potøebuje víceúrovòové tabulky, v dobì kompilace lze provádìt}
				\begin{itemize}
					\pojem{Kompletnì}{typovou kontrola, detekci cíle skokù, ovìøení existence entity daného jména a typu}
					\pojem{Èásteènì}{inicializace entity pøed prvním ètením}
					\pojem{Vùbec}{Detekce ¹patného pou¾ití promìnných, chyby typové konverze}
				\end{itemize}
			\pojem{Struktorovaný interpret}{komplexnìj¹í sémantika}

			\pojem{Modularní pøekladaè}{generuje kód do jeho relativní formy, ale vy¾aduje je¹tì prùchod spojovacím programem (linkerem)}
			\item \textbf{Modulární interpret}
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Instanciace} \hfill (2x)
	\begin{itemize}
		\pojem{U tøídních jazykù}{Proces vytváøení samotného objektu pomocí pøedpisu daného konkrétní tøídou. Bezprostøednì po vytvoøení objektu je volán konstruktor (klíèové slovo \texttt{new} a jméno tøídy), které naplní datové polo¾ky objektu.}
		\begin{itemize}
			\item Popis:
			\begin{enumerate}
				\item alokoval pamì» ("vytvoøí se objekt" je pøíli¹ obecné)
				\item inicializovat objekt (zavolat konstruktor)
			\end{enumerate}
			\item Typicky nastavujeme odkaz na její tøídu (pøípadnì odkaz na tabulku virtuálních metod)
			\item Hierarchie dìdièností tøídy, kterou instanciuji, ovlivòuje poøadí volání konstruktorù.
		\end{itemize}
		\pojem{U beztøídních jazykù}{Klonováním objektu a pozmìnìním polo¾ek. Nutnost existence praobjektu.}
		\begin{itemize}
			\item Je tøeba provést i pøípadnou úpravu polo¾ek (resp. slotù) \tedy a» u¾ datových nebo metodových nebo tøeba i pøidání nových
			\item Mo¾né je také vytvoøit zcela prázdný objekt (není tøeba mít nìjaký jiný ji¾ existující objekt) a pak mu pøidat v¹echny potøebné polo¾ky (resp. sloty)
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Beztøídní jazyky} \hfill (1x)
	\begin{itemize}
		\item JavaScript, Self, 
	\end{itemize}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Backtracking} \hfill (3x)
	\begin{itemize}
		\item Metoda zpìtného navracení
		\item Pou¾ívá pro svoji implementaci zásobník
		\item Zanoøuje se co nejvíce do hloubky, dokud nedojde k neúspìchu podcíle, poté se vrátí o úroveò vý¹e a znovu zkou¹í najít øe¹ení. Zastaví se pøi splnìní v¹ech podcílù a nalezení cíle.
		\item Vyu¾ívá prolog
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%\subsection{Optimalizace v SQL\hfill (1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Datové typy (Pøístup k polo¾ce v bitovém poli)} \hfill (2x)
	\begin{itemize}
		\pojem{n-tice}{datová struktura jednoznaènì definovaná svým jménem}
		\begin{itemize}
			\item Ka¾dá slo¾ka má typ, je pojmenována a zpøístupnìna pouze skrze toto jméno
			\item Ulo¾ení v pamìti \tedy tìsnì za sebou, aby zabrala co nejménì pamìti
		\end{itemize}

		\pojem{Variantní datová struktura}{sjednocení jednotlivých slo¾ek struktury}
		\begin{itemize}
			\item Ka¾dá slo¾ka má také jméno a typ, je mo¾né k ní pøistupovat pro ètení i zápis
			\item Slo¾ky se pøekrývají \tedy aktivní je právì jedna
			\item Velikost obsazené pamìti je urèena nejvìt¹í slo¾kou
			\item Pøístup do slo¾ek \tedy pomocí adresy datové struktury + posunutí (offset) v rámci struktury
		\end{itemize}

		\pojem{Bitová pole}{Zarovnávají svou velikost na nejbli¾¹í byte nebo word}
		\begin{itemize}
			\item Pøístup k polo¾ce \tedy adresa struktury a posunutí bitového pole + posunutí bitového pole v rámci úseku bitových polí
			\item Pro vyètení/zápis hodnoty nestaèí kód pro pøístup pamìti, ale musí se pou¾ít instrukce/operace pro posunutí/rotace v rámci slova/byte a operace pro maskování
		\end{itemize}

		\pojem{Pole}{homogenní datová struktura s pevným indexem}
		\begin{itemize}
			\item Slo¾ky jsou za sebou v pamìti (mù¾ou mít mezery)
			\item \texttt{<baze> - x*sizeof(<typ>)} \tedy mo¾né vypoèítat v dobì pøekladu (mapovací funkce)
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Typovost} \hfill (9x)
	\begin{itemize}
		\item \textbf{Beztypové:}
		\begin{itemize}
			\item Neobsahují typy, typické pro teoretické a formální jazyky a nebo jazyk s jedním univerzálním typem.
		\end{itemize}
        \item \textbf{Netypované:}
        \begin{itemize}
			\item Explicitnì se nezapisuje typ promìnné, ale podle kontextu je to jasné o jaký typ se jedná.
		\end{itemize}
        \item \textbf{Typované:}
        \begin{itemize}
			\item Ka¾dá promìnná má explicitnì uvedený typ. Pøiøazení typu je bud explicitní, nebo automaticky odvozené = Typová inference (Typ je odvozen automaticky z operandù a operací. Haskell, dodateènì pøidáno do C++11, C\#, Visual Basic).

			\pojem{Pøísnì typované jazyky}{v¾dy je nutná explicitní typová konverze -- jinak dochází k automatické typové konverzi podle pravidel jazyka (vìt¹í nároky na pøeklad, analýzu)}
			
			\item Dìlení jazykù dle dùkladnosti typové kontroly:
			\begin{itemize}
				\pojem{Silnì typované jazyky}{Neexistuje mo¾nost jak implicitnì zpùsobit typovou chybu/nekonzistenci s výjimkou explicitní typové konverze s vypnutou typovou kontrolou.}
				\item \textbf{Støednì silnì typované jazyky}{}
				\pojem{Absolutnì silnì typované jazyky}{Jsou silnì typované a neobsahují naprosto ¾ádné implicitní konverze}
				\pojem{Slabì typované jazyky}{I po úspì¹né kompilaci mù¾e dojít k typové chybì.}
			\end{itemize}
        \end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Objekt(zapouzdøení, vícetypové, operace)} \hfill (4x)
	\begin{itemize}
		\item \textbf{Tøída} $=$ objekt/entita obsahující:
		\begin{itemize}
			\item seznam instanèních atributù
			\item data tøídních atributù
			\item impelementace metod
			\item reference na její tøídu
		\end{itemize}
		\pojem{Instance}{identita + ''reference na její tøídu'' + data instanèních atributù}
		\pojem{Extent}{kolekce v¹ech instancí dané tøídy, ''tøída'' jako mno¾ina}

		\pojem{Tøídní dìdiènost}{sdílení/znovupou¾ití polo¾ek skrz tøídy}
		\pojem{Podtøída}{odvozená tøída popisující zmìny oproti pøímé nadtøídì}
		\begin{itemize}
			\item Replikace a pøidání nových polo¾ek
			\item Redefinice zdìdìných metod (\emph{overriding})
		\end{itemize}

		\item \textbf{Operace nad instancemi:}
		\begin{itemize}
			\item Pøístup k atributùm \tedy poøadí/umístìní zná tøída
			\item Zaslání zprávy instanci \tedy jednotný protokol
			\begin{itemize}
				\item Získání tøídy, hledání metody ve tøídì a nadtøídách
				\item Invokace metody
				\item Návrat hodnoty výsledku odesílateli
			\end{itemize}
			\item Modifikátory pøístupu \tedy konfigurace zapouzdøení (\texttt{private, protected, internal, public})
		\end{itemize}
		\item \textbf{Operace nad tøídami:}
		\begin{itemize}
			\item Tøída jako objekt první kategorie
			\item Tøída jako speciální entita jazyka
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Mnohotvárnost(Polymorfismus)} \hfill (1x)
	\begin{itemize}
		\item Stejnou zprávu lze zaslat rùzným objektùm! Nìkteré OOJ toto v¹ak omezují typovým systémem
		\item Protokol umo¾òuje individuální reakci, proto¾e kvùli zapouzdøení neznám implementaci invokované metody (a ta se mù¾e pro rùzné objekty li¹it)
		\item Nìkteré OOJ umo¾òují druh vazby urèit pro ka¾dou zprávu (jeden typ vazby bývá implicitní \tedy virtuální metody v C++ nebo implicitní pozdní vazba v Javì nebo Smalltalku (nelze zmìnit))
		\pojem{Statické (v dobì pøekladu) urèení reakce}{brzká vazba}
		\pojem{Dynamické (za bìhu) urèení reakce}{pozdní vazba}
		\pojem{Napø}{máme objekt orel a po¹leme mu zprávu \texttt{rychle\_se\_premisti}. Implementace reagující metody bude obsahovat pøíkazy rozta¾ení køídel a vzlétnutí. U objektu gepard, ale bude implementace metody volané po obdr¾ení zprávy obsahovat pøíkaz rozbìhni se. Ta samá promìnná programu mù¾e bìhem jeho bìhu obsahovat èi odkazovat na rùzné objekty. Umo¾òuje na místì jednoho objektu pou¾ívat jiný bez nutnosti jakýchkoliv zásahù do programu}
	\end{itemize}

	\subsection{Dìdiènost} \hfill (1x)
	\begin{itemize}
		\item Musíme v ka¾dém objektu implementovat stejné metody, aby rozumìli stejné mno¾inì zpráv? Ne! 
		\item Sdílení spoleèných polo¾ek (od pøedkù) + individuální polo¾ky (v potomcích)
		\item Primárnì pro sdílení/znovupou¾ití metod
		\pojem{Úèely dìdiènosti}{}
		\begin{enumerate}
			\item Znovupou¾ití definované tøídy pro specifiètìj¹í verzi tøídy (typu)
			\item Zaji¹tìní zpìtné kompatibility z pohledu rozhraní instancí zdìdìných tøíd
		\end{enumerate}
		\pojem{Specializace zdìdìného objektu}{}
		\begin{itemize}
			\item Pøidání nových polo¾ek
			\item Modifikace metod
			\pojem{Nezvyklé}{atributù, odebrání/zakázání polo¾ek}	
		\end{itemize}
		\pojem{Klasifikace}{}
		\begin{enumerate}
			\pojem{Jednoduchá}{ka¾dý potomek má nejvý¹e jednoho pøímého pøedka (rodièe)}
			\pojem{Vícenásobná}{tøída mù¾e dìdit od více pøímých pøedkù (více ne¾ jednoho) \tedy vznikají problémy s konflikty a duplikací jmen}
			\pojem{Dìdiènost implementace}{zahrnuty celé metody vèetnì implementace \tedy V pøípadì vícenásobné dìdiènosti je zde problém s rùznými implementacemi dvou stejných metod}
			\pojem{Dìdiènost rozhraní}{Odstraòuje problém s konfliktními jmény u vícenásobné dìdiènosti. Jde o seznam metod, které je nutno v potomkovi implementovat. Vy¾adovaná dìdiènost -- Je-li instance tøídy nebo z ní dìdìné tøídy vy¾adována na místì parametru metody. Dìdièný vztah zaji¹»uje existenci protokolu (zaruèí, ¾e bude tøída rozumìt urèité mno¾inì zpráv)}
		\end{enumerate}
	\end{itemize}

	\subsection{Ru¹ení objektù } \hfill (1x)
	\begin{itemize}
		\pojem{Automaticky}{pouze pøi bìhu objektového prostøedí ve virtuálním stroji a provádí jej nástroj zvaný Garbage Collector, který jednou za èas vyhledá objekty, na které ji¾ neexistuje ¾ádný odkaz a ty zru¹í. Tìsnì pøed zru¹ením je mo¾no zavolat speciální metodu pro úklid a uvolnìní alokovaných zdrojù mimo objekt $=$ Finalizace}
		\pojem{Manuálnì}{nemáme vìt¹inou Garbage Collector. Pro likvidaci objektu je vyèlenìna speciální metoda, tzv. destruktor, na jejím¾ konci je objekt uvolnìn z pamìti. Virtuální destruktor $=$ Umo¾òuje pozdní vazbu jako virtuální metody}
	\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Funkcionální a logické jazyky} \hfill (3x)
	\begin{itemize}
		\item \textbf{Funkcionální: \hfill \emph{(LISP)}}
		\begin{itemize}
			\item Funkce je základním a jediným výrazovým prostøedkem pro popis a definici algoritmù i dat
			\item Umo¾òují rychlý vývoj programù, které jsou ve srovnání s imperativními programy men¹í
			\item Díky existenci formální báze lze provádìt formální dùkazy vlastností algoritmù
        \end{itemize}
        \item \textbf{Logické: \hfill \emph{(Prologue)}}
        \begin{itemize}
			\item Program v logických programovacích jazycích sestává z predikátù pøípadnì kombinovaných s omezeními, které pracují nad atomy, termy, èi predikáty
			\item Mají Garbage Collector
			\item Modularita jen na úrovni zdrojových kódù
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Staticky explicitnì typovaný strukturální jazyk} \hfill (1x)
	\begin{itemize}
		\item Co mù¾eme kontrolovat v urèitých fázích chodu:
		\pojem{Bìhem pøekladu}
		\begin{itemize}
			\item typová kontrola, detekce cíle skokù, ovìøení existence entity daného jména a typu.
        \end{itemize}
		\pojem{Za bìhu}
		\begin{itemize}
			\item Detekce ¹patného pou¾ití promìnných, chyby typové konverze.
        \end{itemize}
        \pojem{Èásteènì za bìhu/pøekladu}
        \begin{itemize}
			\item Inicializace entity pøed prvním ètením
        \end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Strukturální a nestrukturální jazyky (pøedávání struktur hodnotou do podprogramu)} \hfill (4x)
	\begin{itemize}
		\item Nelze
		\item Implementace je standardním zpùsobem, nicménì mù¾e být limitována velikost takto pøedávané struktury.
		\item Pro velké struktury je také mo¾ná implementace, kdy se nevytváøí pøi volání podprogramu kopie dat struktury na standardní místo (typicky programový zásobník), ale vytváøí se na místo na haldì (heap) a potom se k ní pøistupuje odkazem. Takováto implementace je samozøejmì pomalej¹í.
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Syntéza} \hfill (4x)
	\begin{itemize}
		\item Automatická implementace obvodu dle HDL modelu (HDL model \tedy prvky obvodu cílové platformy)
		\item Pøedchází procesu fyzické implementace (ASIC/FPGA)
		\item Vstup:	
		\begin{itemize}
			\item Behaviorální specifikace
			\item Sada omezení (constraints)
			\item Cíl optimalizace (goal) a úsilí (effort)
			\item Technologické knihovny (technology library (no shit sherlock))
		\end{itemize}
		\item Výstup:
		\begin{itemize}
			\item RTL implementace (netlist)
		\end{itemize}
		\item Úrovnì syntézy:
		\begin{itemize}
			\item High Level Synthesis (Behavioral / Algorithmic Synthesis)
			\item RTL synthesis
			\item Logic synthesis
			\item Layout synthesis
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Imperativní / deklarativní jazyky} \hfill (4x)
	\begin{enumerate}
		\item \textbf{Imperativní}
		\begin{itemize}
			\item programátor øe¹í, jaké operace mají být provedeny a v jakém poøadí mají být provedeny
			\item na vy¹¹í úrovni programového kódu u souèasných jazykù rozpoznáváme typy abstrakce pro øízení bìhu programu
			\item podprogramy, bloky, koprogramy, paralelní programy, odlo¾ené zpracování
		\end{itemize}
		\item \textbf{Deklarativní}
		\begin{itemize}
			\item programátor øe¹í, jaké operace mají být provedeny
			\item Dle typu jazyka jsou rùzné strategie vyhodnocení a volání podprogramù:
			\begin{itemize}
				\pojem{Volání hodnotou}{\texttt{call-by-value}}
				\begin{itemize}
					\item Parametry se vyhodnocují pøed voláním podprogramu
					\item V pøípadì, kde se eliminuje opakované vyhodnocení stejných parametrù\tedy striktním vyhodnocení
				\end{itemize}
				\pojem{Volání jménem}{\texttt{call-by-name}}
				\begin{itemize}
					\item Parametry se do volaného podprogramu pøedávají nevyhodnocené a reprezentované zástupným jménem
					\item K jejich vyhodnocení dojde, a¾ to vy¾aduje volaný podprogram
					\item Výraz ve výsledku nemusí být vyhodnocen ani jednou, ale také vícekrát \tedy nestriktní vyhodnocování
				\end{itemize}
				\pojem{Volání v pøípadì potøeby}{\texttt{call-by-need}}
				\begin{itemize}
					\item Podprogram je zavolán, kdy¾ jeho vyhodnocení potøebuje hodnotu nìjakého parametru, dojde k jeho vyhodnocení, hodnota se uschová pro dal¹í pou¾ití a u¾ se opakovanì nevyhodnocuje \tedy nestriktní, tzv. lazy vyhodnocování
				\end{itemize}
			\end{itemize}
		\end{itemize}
	\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Postup pøi tvorbì procesoru s aplikaènì specifickými instrukcemi} \hfill (1x)
	\begin{itemize}
		\item Návrh architektury
		\begin{itemize}
			\item Zji¹tìní kritických èástí aplikace, které vy¾adují podporu hardwaru dostupné pøes aplikaènì specifické instrukce
			\item Definování instrukèní sady
			\item Ustálení mikroarchitektury, která implementuje instrukèní sadu (instrukèní dekodér)
		\end{itemize}
		\item Simulace v softwaru
		\item Návrh software pro vybranou aplikaci
		\item Integrace architekturu do systému
	\end{itemize}

	\subsection{Vyjmenovat sloty v beztøídních jazycích s delegací (napø. SELF)} \hfill (1x)
	\begin{itemize}
		\item \textbf{Datové:}
		\begin{itemize}
			\item buï data, nebo odkazy na jiné objekty
        \end{itemize}
        \item \textbf{odkazy na metody:}
        \begin{itemize}
			\item resp. objekty reprezentující metodu
		\end{itemize}
        \item \textbf{rodièovské:}
        \begin{itemize}
			\item odkazy na objekty, na které je pøípadnì delegována zpráva, které daný objekt nerozumí
		\end{itemize}
        \item \emph{Obèas nìkteøí zaèali ¹patnì vysvìtlovat význam rodièovského slotu (¾e odkazuje na objekt, ze kterého ten ná¹ vznikl, co¾ tak není -- zamyslete se nad tím, ¾e klonování prototypu probíhá mìlkou kopií)}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Co je to ukazatel a nìco s cílovou architekturou} \hfill (1x)
	\begin{itemize}
		\item Datový typ nesoucí adresu teoreticky libovolné pamì»ové buòky v cílovém systému
		\item ideální pøípad - systém s plochým adresovým prostorem \tedy ukazatel je nejmen¹í celoèíselný typ, který pojme v¹echny adresy
		\item IRL je tøeba brát v potaz:
		\begin{itemize}
			\item Segmentaci pamìti
			\item Stránkování
			\item Zarovnání pamìti a velikost slova (Napø. u pamìti organizované po 16b se typicky pøistupuje na sudé adresy, bráno po bytech)
			\item Oddìlení prostoru pro datovou a kódovou pamì» (Harvardská architektura)
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Rozdíly mezi G\"odel a Prologem} \hfill (1x)
	\begin{itemize}
		\item \textbf{G\"odel}
		\begin{itemize}
			\item Neprohledává do hloubky, ale hledá nejvýhodnìj¹í podcíl
			\item Má mnohem vìt¹í výrazovou sílu
			\item Nepomáhá Hornovy klauzule
			\item Má mo¾nost definovat u¾ivatelské typy
			\item Lep¹í pøedpoklady ale nebyl roz¹íøen
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Rozdíl mezi Handel-C a C, jak se modeluje v Handel-C paralelizmus.} \hfill (1x)
	\begin{itemize}
		\item Handel-C vychází z ANSI-C a roz¹iøuje jej
		\item floating point datové typy pouze v externích knihovnách
		\item Paralelismus:
		\begin{verbatim}a = 3;
par {
    a = 7;
    seq {
        b = 4;
        c = 5;
    }
}
		\end{verbatim}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Jak jazyk nML popisuje instrukèní sadu} \hfill (1x)
	\begin{itemize}
		\item Instrukce je popsána jednou nebo více operacemi
		\item dva zpùsoby budování hierarchie operací (AND, OR)
		\item dva dùle¾ité atributy popisu operací - image, syntax
		\item instrukèní sada je popsána pomocí atributované gramatiky
		\begin{itemize}
		\item ka¾dý element v hierarchii má nìkolik atributù a hodnota atributù nelistových elementù mù¾e být poèítána na základì hodnot atributù potomkù
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Uveïte hlavní rozdíl mezi vnitøním a vnìj¹ím protokolem zapouzdøeného objektu v OOJ } \hfill (4x)
	\begin{itemize}
		\item Interním protokolem se objekt øídí, pokud zaslal objekt zprávu sám sobì
		\item Veøejným protokolem se potom objekt øídí ve v¹ech ostatních pøípadech (tj. pokud objektu zaslal zprávu jiný objekt)
    \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{V kódu (tu¹ím imperativního nestrukturovaného jazyka) je \texttt{k+1} jak se mù¾e stát, ¾e to mù¾e být korektnì vyhodnoceno pro k jako øetìzec i èíslo?} \hfill (1x)
	\begin{itemize}
		\item Pøíkladem dynamické vazby mù¾e být tento kousek kódu jazyka Perl:
		\begin{verbatim}if ($p)
		    $x = 10;
		else
		    $x = "abc";
		echo $x+1;
		\end{verbatim}
		\item Podle hodnoty promìnné p je potom výstupem buïto èíselná hodnota 11, nebo øetìzec abc1
	\end{itemize}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Uzavøené podprogramy, co je zajímavé pro programátora} \hfill (1x)
	\begin{itemize}
		\item Týmová spolupráce
		\item Uzavøené podprogramy mohou být vyvíjené nezávisle
		\item Program je mo¾né rozdìlit na logicky nezávislé celky
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Simulace (Interpretovaný a kompilovaný simulátor)}\hfill (1x)
	\begin{itemize}
		\pojem{Interperetovaná}{ka¾dá instrukce se po naètení analyzuje(operaèní kódy, operandy, atd), a mù¾e dojít k opakovanému analyzování}
		\pojem{Kompilovaná}{ka¾dá instrukce se analyzuje pouze jednou, pøièem¾ dojde k její ulo¾ení do pamìti(operaèní kódy, operandy, atd)}
		\pojem{Druhy simulátorù}{}
		\begin{enumerate}
			\pojem{Simulátor zalo¾ený na instrukcích}{nejmen¹í krok simulace je provedení jedne instrukce. Vytvoøen pro jazyky pro popis instrukèní sady. Výhodou je rychlost simulace}
			\pojem{Simulátor zalo¾ený na cyklech}{nejmen¹í krok simulace je jeden takt hodinového signálu. Vyu¾ívá se u jazykù smí¹ených(instrukèní sada + struktura). Výhodou je ze lze v ka¾dém taktu sledovat stav zpracovávané instrukce. Simulace je pomalej¹í}
		\end{enumerate}
	\end{itemize}
	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Rys vs. prototyp} \hfill (1x)
	\begin{itemize}
		\pojem{Rys}
		\begin{itemize}
			\item Je objekt se sdíleným chováním a doplòuje nebo nahrazuje tøídu. 
			\item Je to jedna z èástí, jak nahradit tøídy v prototypových jazycích.
			\item Provázáním rysù dosahujeme dìdiènosti \tedy Aby byla dìdiènost úplná je tøeba mít i prototyp, co¾ je objekt, který obsahuje atributy instanèní promìnné.
			\item Tedy prototyp je ¹ablona instanèních promìnných a nové objekty se tvoøí klonováním (kopírování mìlké).
		\end{itemize}
		\pojem{Prototyp}
		\begin{itemize}
			\item ©ablona instancí (instanèních promìnných s implicitními hodnotami)
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Vazby} \hfill (1x)
	\begin{itemize}
		\pojem{Statická (èasná) vazba}
		\begin{itemize}
			\item Pøi pøekladu se kontroluje správnost pou¾ití objektù a volí volané metody
		\end{itemize}
		
		\pojem{Dynamická (pozdní) vazba}
		\begin{itemize}
			\item Volí potøebné metody objektù a¾ za bìhu programu
			\item K implementaci tohoto mechanismu se vyu¾ívají tabulky virtuálních metod - VMT
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Sigma kalkul -- obecnì} \hfill (4x)
	\begin{table}[h]
		\center
		\begin{tabular}{l  l}
			$\varsigma$-zápis & Vázanost promìnných \\ \hline
			$m=\varsigma(x)x$ & x je v tomto pøípadì vázaná promìnná \\
			$n=\varsigma(y)x$ & x není vázaná promìnná \\
			$l=\varsigma(x)[q=\varsigma(y)x]$ & x je vázaná promìnná (uvnitø) \\
		\end{tabular}
	\end{table}

	\subsection{Lambda kalkul -- redukce} \hfill (furt)
	Redukce - atfa,beta,eta
	
	\texttt{($\lambda$f n.n f m n) ($\lambda$x y.y) | beta [($\lambda$x y.y)/f]} \hfill tìlo je v tomto pøípadì (\texttt{n f m n})

	\texttt{($\lambda$n.n ($\lambda$x y.y) m n)} \hfill tìlo je v tomto pøípadì (\texttt{n ($\lambda$x y.y) m n})

	- nemohu u¾ dále pou¾ít ¾ádnou beta redukci - konèím

	výsledek: \texttt{($\lambda$n.n ($\lambda$x y.y) m n)} \\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{2 zpùsoby volání konstruktoru v jazycích s vícenásobnou dìdièností} \hfill (1x)
	\begin{itemize}
		\item Vyu¾ití poøadí zápisu tøíd ve zdrojovém textu, v jakém byly v seznamu rodièovských tøíd instanciované tøídy uvedeny
		\item Ignorování zápisu ve zdrojovém textu, ale vyu¾ití u¾ivatelem definovaného poøadí inicializace, které ov¹em není dodateènì kontrolováno na pøípadné uváznutí (angl. deadlock) èi nesprávné poøadí
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{UML} \hfill (1x)
	\begin{itemize}
		\item Slou¾í pro modelovani struktury a chovaní navrhovaného systému
		\pojem{Reprezentace}{}
		\begin{itemize}
			\pojem{Tøída}{jméno tøídy, seznam metod a atributù}
			\pojem{Objekt}{identifikátor objektu + pøípadný identifikátor tøídy, ze které byl instanciován, seznam atributù s hodnotami}
		\end{itemize}
		\pojem{Vztahy mezi prky}{}
		\begin{itemize}
			\pojem{Asociace}{propojení mezi prvky systému}
			\pojem{Agregace/Kompozice}{dekompozice(rozdìlení) na podproblémy}
			\pojem{Závislost}{zmìna v jednom prvku se projeví i v druhém prvku}
			\pojem{Generalizace}{vztah mezi obecnìj¹ím a specifiètìj¹ím prvkem}
			\pojem{Realizace}{vztah mezi návrhem a skuteènou realizací}
		\end{itemize}
		\pojem{Diagramy}{}
		\begin{itemize}
			\pojem{Diagram pøípadu u¾ití}{znázoròuje úèastníky systému, mo¾nosti pou¾ití systému a hranice systému}
			\pojem{Stavový diagram}{vá¾e se na konkrétní tøídu a popisuje do jakých stavù se mohou dostat její instance}
			\pojem{Diagram objektù}{popisuje vzajemné propojení mezi objekty}
		\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Jak upravit jazyk C, aby mohl popisovat HW?} \hfill (1x)
	\begin{itemize}
		\item Podporovat paralelismus (soubì¾né vykonávání operací)
		\item Zavést èasový model (z dùvodu simulace napø.)
		\item Mo¾nost definovat strukturu a chování (Procesor se skládá z ALU, registrù a jak jsou propojené komponenty)
		\item Pøíklady HDL jazykù zalo¾ených na C: Handel C (vychází z ANSI-C), Catapult C
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Mù¾e existovat jazyk bez deklarací se vzájemnì rekurzivními funkcemi?} \hfill (1x)
	\begin{itemize}
		\item Nemù¾e \tedy deklarace je nezbytná pro vzájemnì rekurzivní funkce z dùvodu toho, ¾e se mohou volat navzájem a musí tedy vìdìt o v¹ech ostatních funkcích, pokud je chce volat
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Rozdíl mezi vynucenou dìdièností a skuteèným podtypem?} \hfill (1x)
	\begin{itemize}
		\pojem{Vy¾adovaná dìdiènost}{pokud má nìjaká metoda jako atribut instanci nìjaké tøídy, mù¾e se na místì tohoto parametru objevit pouze instance této tøídy, nebo nìjaká pøímo nebo nepøímo dìdìná podtøída. Proto¾e dìdiènost zaji¹»uje, ¾e bude urèitì rozumìt po¾adovaným zprávám}
		\pojem{Skuteèný podtyp}{v pøede¹lém pøípadì kontroluje pouze, jestli má zadaná metoda potøebné metody (jestli rozumí potøebným zprávám)}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Existuje jazyk, který si nutnì vy¾aduje dva prùchody sémantickým analyzátorem?} \hfill (1x)
	\begin{itemize}
		\item Ano \tedy libovolný imperativní jazyk bez nutnosti deklarace funkcí a který umo¾òuje volat funkce, bez toho ani¾ by byla pøedtím definovaná (napø. Java). A to z dùvodu ¾e pøi sémantické analýze nejsme pøesnì schopni urèit umístìní funkcí v programu
	\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Detailnì specifikujte mo¾ný zpùsob pøedávání øízení v modulárních jazycích tak, aby bylo mo¾né moduly bezproblémovì spojovat} \hfill (1x)
	\begin{itemize}
		\item Z dùvodu ¾e je mo¾né pøedávání z jednoho modulu do druhého
		\pojem{Problémy}{}
		\begin{itemize}
			\item Jak pøedat parametry
			\item Jak vrátit a pøijmout výsledek
			\item Jak vyu¾ít registry
		\end{itemize}
		\pojem{Øe¹ení}{}
		\begin{itemize}
			\item Registry se pou¾ívají jen v rámci funkcí
			\item Standardizace pøedávání parametrù
			\pojem{Pøedání hodnotou}{spoèítá se výraz (hodnota parametru) a vytvoøí se lokální promìnná inicializovaná na hodnotu výrazu. S koncem programu zanikne i tato promìnná}
			\pojem{Pøedání výsledkem}{lokální promìnná s neznámou inicializací, pracuje se s ní, a jakmile podprogram skonèí, nakopíruje se její hodnota do promìnné, která se pøedává jako parametr (výsledek)}
			\pojem{Pøedání hodnotou a výsledkem}{spoèítá se výraz (to je parametr), vytvoøí se lokální promìnná, do které se výsledek výrazu nakopíruje. S touto lokální promìnnou se pracuje a na konci se nakopíruje zpìt do promìnné, ze které se pùvodnì pøedával výsledek výrazu (parametr) nakopíruje výsledek}
			\pojem{Pøedání odkazem}{pøedáme ukazatel na promìnnou jako parametr, s ní se po celou dobu pracuje a po ukonèení programu je v promìnné ulo¾en výsledek}
			\pojem{Pøedání jménem}{místo výrazu se pøedává dvojice funkcí (jedna na vyhodnocení výrazu a druhá na ulo¾ení výsledku)}
		\end{itemize}
	\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{3 jazyky pro popis architektur a jejich charakteristiky} \hfill (1x)
	\begin{itemize}
		\item ADL jazyky jsou jazyky pro popis architektury procesoru
		\pojem{Jazyky zamìøené na instrukèní sadu}{pohled na architekturu pøes popis instrukèní sady, neobsahují dal¹í informace o mikro architektuøe, obsahují pouze sémantiku instrukcí}
		\begin{itemize}
			\pojem{nML}{vyu¾ívá formalismy pro popis instrukèní sady. Popsaná pomocí atributované gramatiky, atributy popisu operací (image \tedy binární reprezentace / syntax \tedy assemblerovský zápis operace). Èásti jazyka: popis instrukèní sady, struktury, èasování a chování. Hlavní nedostatek: nepodporuje instrukce zøetìzení}
			\pojem{ISDL}{popis instrukèní sady procesorù VLIW. Podobný nML, roz¹íøen o definici omezení, co urèuje instrukce platné pøi konfliktech. Neumo¾òuje popis zøetìzení}
		\end{itemize}
		\pojem{Jazyky zamìøené na strukturu}{zamìøují se na strukturu a propojení architektury, nevýhodou je pomalost simulátorù, ni¾¹í úroveò abstrakce}
		\begin{itemize}
			\pojem{MIMOLA}{návrh mikro-architektury. Nevýhoda, nízká úroveò abstrakce \tedy pomalý simulátor. Skládá se ze dvou èástí (HW èást \tedy specifikuje architekturu / SW èást \tedy popisuje program v syntaxi podobné PASCALu)}
			\pojem{Coach}{zalo¾en na jazyku UDL/I = popis procesoru na úrovní pøenosù mezi registry, zalo¾en na jednotlivých cyklech. Výhoda \tedy popis v UDL/I je plnì syntetizovatelný. Nevýhoda \tedy pomalý simulátor}
		\end{itemize}
		\pojem{Jazyky zamìøené na instrukèní sadu a strukturu}{}
		\begin{itemize}
			\pojem{LISA}{Detailnì popasána vý¹e}
			\pojem{ASIA}{pracuje s instrukèní sadou a mikroarchitekturou}
		\end{itemize}
	\end{itemize}

	\subsection{Robinsonùv algoritmus} \hfill (2)
		Viz \ref{teor:robinson}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%\newpage
	%{\Large JE©TÌ NEMÁME HOTOVÉ}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%\subsection{Lokální promìnné v bloku a lokální funkce ve funkci \hfill (2)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%\subsection{Minimální model výpoètu èistého OOJ, jak jsou øe¹eny atributy, pøístup k nim\hfill (1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%\subsection{Existuje jazyk, který nutnì vy¾aduje dva prùchody semantickým analyzátorem? Zdùvodnìte\hfill (1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%\subsection{Modularní jazyky\hfill (1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
	%\subsection{Co musí umìt kompilátor, aby mohl spojovat moduly\hfill (1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%\subsection{Hardware\hfill (3)}



\end{document}
